/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["GUI"] = factory();
	else
		root["GUI"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ArgoDG/src/complex_geom.js":
/*!*************************************************!*\
  !*** ./node_modules/ArgoDG/src/complex_geom.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* reexport safe */ _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1),\n/* harmony export */   \"Circline\": () => (/* reexport safe */ _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__.Circline),\n/* harmony export */   \"Complex\": () => (/* reexport safe */ _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex),\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* reexport safe */ _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2),\n/* harmony export */   \"Moebius\": () => (/* reexport safe */ _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius)\n/* harmony export */ });\n/* harmony import */ var _complex_geom_complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex_geom/complex.js */ \"./node_modules/ArgoDG/src/complex_geom/complex.js\");\n/* harmony import */ var _complex_geom_cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_geom/cp1.js */ \"./node_modules/ArgoDG/src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_geom_complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_geom/complex_matrix.js */ \"./node_modules/ArgoDG/src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _complex_geom_moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./complex_geom/moebius.js */ \"./node_modules/ArgoDG/src/complex_geom/moebius.js\");\n/* harmony import */ var _complex_geom_circline_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./complex_geom/circline.js */ \"./node_modules/ArgoDG/src/complex_geom/circline.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/complex_geom.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/complex_geom/circline.js":
/*!**********************************************************!*\
  !*** ./node_modules/ArgoDG/src/complex_geom/circline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circline\": () => (/* binding */ Circline)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./node_modules/ArgoDG/src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./node_modules/ArgoDG/src/complex_geom/cp1.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex_matrix.js */ \"./node_modules/ArgoDG/src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _moebius_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./moebius.js */ \"./node_modules/ArgoDG/src/complex_geom/moebius.js\");\n\n\n\n\n\nclass Circline {\n    constructor(A, B, C, D) {\n        if (arguments.length == 1 && arguments[0] instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2)\n            this.H = arguments[0];\n        else {\n            if (!A.is_zero()) {\n                const a = 1 / A.norm();\n                A = A.scale(a);\n                B = B.scale(a);\n                C = C.scale(a);\n                D = D.scale(a);\n            }\n            this.H = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_2__.ComplexMatrix2x2(A, B, C, D);\n        }\n    }\n\n    static mk_circle(a, r) {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, a.uminus(),\n                            a.cnj().uminus(), a.mult(a.cnj()).sub(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r*r)));\n    }\n\n    static mk_line(z1, z2) {\n        const B = z2.sub(z1).mult(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i);\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, B,\n                            B.cnj(), _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.cnj_mix(B.uminus(), z1));\n    }\n    \n    on_circline(z, eps) {\n        if (!eps)\n            eps = 1e-2;\n        return (z.conjugate().vec_mult(this.H.multCP1(z))).is_zero(eps);\n    }\n\n    in_disc(z) {\n        const EPS = 1e-12;\n        const v = z.conjugate().vec_mult(this.H.multCP1(z));\n        return v.re < -EPS;\n    }\n\n    is_line() {\n        return this.H.A.is_zero();\n    }\n\n    is_circle() {\n        return !this.is_line();\n    }\n\n    circle_center() {\n        return this.H.B.uminus().div(this.H.A);\n    }\n\n    circle_radius() {\n        return Math.sqrt(this.H.B.mult(this.H.C).sub(this.H.A.mult(this.H.D)).div(this.H.A.mult(this.H.A)).re);\n    }\n\n    line_points() {\n        const z1 = this.H.D.mult(this.H.B).uminus().div(this.H.B.mult(this.H.C).scale(2));\n        const z2 = z1.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((this.H.B.arg() > 0 ? this.H.B.uminus() : this.H.B).sgn()));\n        return [z1, z2];\n    }\n\n    static unit_circle() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_one);\n    }\n\n    static x_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.minus_i, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static y_axis() {\n        return new Circline(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static circline3(z1, z2, z3) {\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        return M.inv().moebius_circline(Circline.x_axis());\n    }\n\n    static same_arc(w1, z1, w2, z2) {\n        const cr = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real() && cr.to_complex().re >= 0;\n    }\n\n    static other_arc(w1, z1, w2, z2) {\n        const cr = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.cross_ratio(w1, z1, w2, z2);\n        return !cr.is_inf() && cr.to_complex().is_real() && cr.to_complex().re < 0;\n    }\n    \n    static same_circle(w1, z1, w2, z2) {\n        const cr = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.cross_ratio(w1, z1, w2, z2);\n        return cr.is_inf() || cr.to_complex().is_real();\n    }\n\n    // on a line\n    static between(z1, w, z2) {\n        return Circline.other_arc(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf, z1, w, z2);\n    }\n\n    // on a line\n    static collinear(z1, z2, z3) {\n        return Circline.same_circle(z1, z2, z3, _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf);\n    }\n\n    // on a line\n    static same_side(w1, w2, z1) {\n        return Circline.collinear(w1, w2, z1) && !Circline.between(w1, z1, w2);\n    }\n\n    // on a poincare line \n    static h_between(z1, w, z2) {\n        return Circline.other_arc(w, z1, w.inversion(), z2);\n    }\n\n    three_points() {\n        if (!this._three_points) {\n            if (this.is_line()) {\n                const [z1, z2] = this.line_points();\n                this._three_points = [z1, z2, z1.add(z2.sub(z1).scale(2))];\n            } else {\n                const c = this.circle_center();\n                const r = this.circle_radius();\n                this._three_points = [c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(-r)), c.add(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_imag(r))];\n            }\n        }\n        return this._three_points;\n    }\n\n    random_point() {\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const part = Math.floor(Math.random() * 3);\n        let x;\n        if (part == 0)\n            // [0, 1]\n            x = Math.random();\n        else if (part == 1)\n            // [1, infty]\n            x = 1 / Math.random();\n        else\n            // [-infty, 0]\n            x = 1 - 1 / Math.random();\n\n        return M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n    }\n\n    random_point_in_disc(disc) {\n        const [p1, p2] = this.intersect(disc);\n        const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n        const M = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        const [x1, x2] = [p1, p2].map(p => M.moebius_pt(p).to_complex().re).sort()\n        let p;\n        const MAX_ITER = 100;\n        let iter = 0;\n        do {\n            let x;\n            if (Math.random() < 0.5)\n                x = x1 + Math.random() * (x2 - x1);\n            else {\n                const k = Math.floor(5*Math.random());\n                const d = Math.pow(10, k)*Math.random();\n                x = Math.random() < 0.5 ? x1 - d : x2 + d;\n            }\n            p = M.inv().moebius_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(x));\n            iter++;\n        } while (!disc.in_disc(p) || iter >= MAX_ITER);        \n        return p;\n    }\n\n    moebius_to_xaxis() {\n        if (!this._moebius_to_xaxis) {\n            const [z1, z2, z3] = this.three_points().map(p => _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p));\n            this._moebius_to_xaxis = _moebius_js__WEBPACK_IMPORTED_MODULE_3__.Moebius.moebius_01inf(z1, z2, z3);\n        }\n        return this._moebius_to_xaxis;\n    }\n\n    intersect(other) {\n        const M = this.moebius_to_xaxis();\n        const cm = M.moebius_circline(other);\n        const [A, B, D] = [cm.H.A, cm.H.B, cm.H.D];\n        let p1, p2;\n        if (A.is_zero()) {\n            p1 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.inf;\n            if (B.is_imag())\n                return [p1, p1];\n            p2 = _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(- D.re / (2 * B.re));\n            return [p1, p2].map(p => M.moebius_inv_pt(p));\n        } else {\n            const discr = B.re * B.re - A.re * D.re;\n            if (discr <= 0) {\n                const sqrt = Math.sqrt(-discr);\n                const [p1, p2] = [new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re / A.re, +sqrt / A.re),\n                                  new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(-B.re / A.re, -sqrt / A.re)];\n                return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(p)));\n            } else {\n                const sqrt = Math.sqrt(discr);\n                const [p1, p2] = [(-B.re + sqrt) / A.re,\n                                  (-B.re - sqrt) / A.re];\n                return [p1, p2].map(p => M.moebius_inv_pt(_cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_real(p)));\n            }\n        }\n    }\n\n\n    transform(t) {\n        let three_points = this.three_points();\n        if (three_points.some(p => isNaN(p.re)))\n            return this;\n        three_points = three_points.map(p => {\n            const [re, im] = t(p.re, p.im);\n            return _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(re, im));\n        });\n        return Circline.circline3(...three_points);\n    }\n\n    normalize() {\n        if (!this.H.A.is_zero()) {\n            this.H = this.H.multC(this.H.A.recip());\n        } else if (!this.H.D.is_zero()) {\n            this.H = this.H.multC(this.H.D.recip());\n        } else {\n            this.H = this.H.multC(this.H.B.recip());\n        }\n    }\n\n    eq(other) {\n        this.normalize();\n        other.normalize();\n        return this.H.A.eq(other.H.A) && this.H.B.eq(other.H.B) && this.H.C.eq(other.H.C) && this.H.D.eq(other.H.D);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/complex_geom/circline.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/complex_geom/complex.js":
/*!*********************************************************!*\
  !*** ./node_modules/ArgoDG/src/complex_geom/complex.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Complex\": () => (/* binding */ Complex)\n/* harmony export */ });\n/**\n * Complex number\n */\nclass Complex {\n    constructor(re, im) {\n        this.re = re;\n        this.im = im;\n    }\n\n    static of_real(re) {\n        return new Complex(re, 0);\n    }\n\n    static of_imag(im) {\n        return new Complex(0, im);\n    }\n\n    static get zero() {\n        return zero;\n    }\n\n    static get one() {\n        return one;\n    }\n\n    static get minus_one() {\n        return minus_one;\n    }\n\n    static get i() {\n        return i;\n    }\n    \n    static get minus_i() {\n        return minus_i;\n    }\n\n    clone() {\n        return new Complex(this.re, this.im);\n    }\n\n    add(other) {\n        return new Complex(this.re + other.re, this.im + other.im);\n    }\n\n    mult(other) {\n        if (typeof other == \"number\")\n            return this.scale(number);\n        return new Complex(this.re * other.re - this.im * other.im,\n                           this.re * other.im + this.im * other.re);\n    }\n\n    scale(k) {\n        return new Complex(k * this.re, k * this.im);\n    }\n\n    uminus() {\n        return this.scale(-1);\n    }\n\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    norm2() {\n        return this.re * this.re + this.im * this.im;\n    }\n\n    norm() {\n        return Math.sqrt(this.norm2());\n    }\n\n    arg() {\n        return Math.atan2(this.im, this.re);\n    }\n\n    sgn() {\n        return this.scale(1 / this.norm());\n    }\n\n    cnj() {\n        return new Complex(this.re, -this.im);\n    }\n    \n    recip() {\n        return this.cnj().scale(1 / this.norm2())\n    }\n\n    div(other) {\n        return this.mult(other.recip());\n    }\n\n    // precision for checking zero\n    static EPS = 1e-8;\n    \n    is_zero(eps) {\n        if (!eps)\n            eps = Complex.EPS;\n        return this.norm2() < eps * eps;\n    }\n\n    is_real() {\n        return Math.abs(this.im) < Complex.EPS;\n    }\n\n    is_imag() {\n        return Math.abs(this.re) < Complex.EPS;\n    }\n    \n    eq(other) {\n        return this.sub(other).is_zero();\n    }\n\n    static cnj_mix(z1, z2) {\n        return z1.cnj().mult(z2).add(z2.cnj().mult(z1));\n    }\n\n    static scalprod(z1, z2) {\n        return Complex.cnj_mix(other).scale(1 / 2);\n    }\n\n}\n\nconst zero      = new Complex( 0,  0);\nconst one       = new Complex( 1,  0);\nconst minus_one = new Complex(-1,  0);\nconst i         = new Complex( 0,  1);\nconst minus_i   = new Complex( 0, -1);\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/complex_geom/complex.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/complex_geom/complex_matrix.js":
/*!****************************************************************!*\
  !*** ./node_modules/ArgoDG/src/complex_geom/complex_matrix.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComplexMatrix2x2\": () => (/* binding */ ComplexMatrix2x2)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./node_modules/ArgoDG/src/complex_geom/complex.js\");\n/* harmony import */ var _cp1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp1.js */ \"./node_modules/ArgoDG/src/complex_geom/cp1.js\");\n\n\n\nclass ComplexMatrix2x2 {\n    constructor(A, B, C, D) {\n        this.A = A;\n        this.B = B;\n        this.C = C;\n        this.D = D;\n    }\n\n    static zero() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\n    }\n\n    static eye() {\n        return new ComplexMatrix2x2(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero,\n                                    _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one);\n    }\n\n    cnj() {\n        return new ComplexMatrix2x2(this.A.cnj(), this.B.cnj(),\n                                    this.C.cnj(), this.D.cnj());\n    }\n\n    transpose() {\n        return new ComplexMatrix2x2(this.A, this.C,\n                                    this.B, this.D);\n    }\n\n    adj() {\n        return this.cnj().transpose();\n    }\n\n    det() {\n        return this.A.mult(this.D).sub(this.B.mult(this.C));\n    }\n\n    inv() {\n        if (!this._inv)\n            this._inv = new ComplexMatrix2x2(this.D, this.B.uminus(),\n                                             this.C.uminus(), this.A).multC(this.det().recip());\n        return this._inv;\n    }\n\n    qr() {\n        if (this._Q == undefined || this._R == undefined) {\n            const s0 = this.C.cnj();\n            const c0 = this.A.cnj();\n            const n = Math.sqrt(s0.norm2() + c0.norm2());\n            const c = c0.scale(1 / n);\n            const s = s0.scale(1 / n);\n            const Qa = new ComplexMatrix2x2(c, s,\n                                            s.cnj().uminus(), c.cnj());\n            this._Q = Qa.adj();\n            this._R = Qa.multM(this);\n        }\n        return [this._Q, this._R];\n    }\n    \n    eq(other) {\n        return this.A.eq(other.A) && this.B.eq(other.B) &&\n               this.C.eq(other.C) && this.D.eq(other.D);\n    }\n\n    is_hermitean() {\n        return this.eq(this.adj());\n    }\n\n    is_zero() {\n        return this.eq(ComplexMatrix2x2.zero());\n    }\n\n    multC(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj), this.B.mult(obj),\n                                    this.C.mult(obj), this.D.mult(obj));\n    }\n\n    multCP1(obj) {\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(this.A.mult(obj.z1).add(this.B.mult(obj.z2)),\n                       this.C.mult(obj.z1).add(this.D.mult(obj.z2)));\n    }\n\n    multInvCP1(obj) {\n        const [Q, R] = this.qr();\n        const rhs = Q.adj().multCP1(obj);\n        const z2 = rhs.z2.div(R.D);\n        const z1  = rhs.z1.sub(R.B.mult(z2)).div(R.A);\n        return new _cp1_js__WEBPACK_IMPORTED_MODULE_1__.CP1(z1, z2);\n    }\n\n    multM(obj) {\n        return new ComplexMatrix2x2(this.A.mult(obj.A).add(this.B.mult(obj.C)),\n                                    this.A.mult(obj.B).add(this.B.mult(obj.D)),\n                                    this.C.mult(obj.A).add(this.D.mult(obj.C)),\n                                    this.C.mult(obj.B).add(this.D.mult(obj.D)));\n    }\n\n    congruence(P) {\n        return P.adj().multM(this.multM(P));\n    }\n}\n\n\n\n/*\nclass Matrix3x3 {\n    constructor() {\n        if (arguments.length == 1)\n            this.M = arguments[0];\n        else if (arguments.length == 9)\n            this.M = [[arguments[0], arguments[1], arguments[2]],\n                      [arguments[3], arguments[4], arguments[5]],\n                      [arguments[6], arguments[7], arguments[8]]];\n    }\n\n\n    static zero() {\n        return new Matrix3x3([[0, 0, 0], [0, 0, 0], [0, 0, 0]]);\n    }\n\n    static eye() {\n        return new Matrix3x3([[1, 0, 0], [0, 1, 0], [0, 0, 1]]);\n    }\n\n    transpose() {\n        const M = Matrix3x3.zero();\n        for (let i = 0; i < 3; i++)\n            for (let j = 0; j < 3; j++)\n                M[i][j] = this.M[j][i];\n        return M;\n    }\n\n    det() {\n        const M = this.M;\n        return  M[0][0]*M[1][1]*M[2][2] + M[0][1]*M[1][2]*M[2][0] + M[0][2]*M[1][0]*M[2][1]\n              - M[2][0]*M[1][1]*M[0][2] - M[2][1]*M[1][2]*M[0][0] - M[2][2]*M[1][0]*M[0][1];\n    }\n\n    mult() {\n        if (arguments.length == 1 && typeof arguments[0] == \"number\") {\n            const M = this.M;\n            const MM = new Matrix3x3(M[0][0], M[0][1], M[0][2], M[1][0], M[1][1], M[1][2], M[2][0], M[2][1], M[2][2]);\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    MM.M[i][j] *= arguments[0];\n            return MM;\n        }\n\n        if (arguments.length == 1 && arguments[0] instanceof Matrix3x3) {\n            const M = Matrix3x3.zero();\n            for (let i = 0; i < 3; i++)\n                for (let j = 0; j < 3; j++)\n                    for (let k = 0; k < 3; k++)\n                        M.M[i][j] += this.M[i][k] * arguments[0].M[k][j];\n            return M.M;\n        }\n            \n        throw \"Not supported\";\n    }\n\n    inv() {\n        function d(a, b, c, d) {\n            return a*d - b*c;\n        }\n        const M = this.M;\n        return new Matrix3x3(d(M[1][1], M[1][2], M[2][1], M[2][2]), d(M[0][2], M[0][1], M[2][2], M[2][1]), d(M[0][1], M[0][2], M[1][1], M[1][2]),\n                             d(M[1][2], M[1][0], M[2][2], M[2][0]), d(M[0][0], M[0][2], M[2][0], M[2][2]), d(M[0][2], M[0][0], M[1][2], M[1][0]),\n                             d(M[1][0], M[1][1], M[2][0], M[2][1]), d(M[0][1], M[0][0], M[2][1], M[2][0]), d(M[0][0], M[0][1], M[1][0], M[1][1])).mult(1 / this.det());\n    }\n    \n}\n*/\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/complex_geom/complex_matrix.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/complex_geom/cp1.js":
/*!*****************************************************!*\
  !*** ./node_modules/ArgoDG/src/complex_geom/cp1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CP1\": () => (/* binding */ CP1)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./node_modules/ArgoDG/src/complex_geom/complex.js\");\n\n\n/**\n * Point in CP1 space (complex projective line),\n * given by its complex homogeneous coordinates\n */\nclass CP1 {\n    constructor(z1, z2) {\n        if (!z2)\n            z2 = _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one;\n        this.z1 = z1;\n        this.z2 = z2;\n        if (!this.z2.is_zero()) {\n            const norm = this.z2.norm();\n            this.z1 = this.z1.scale(1/norm);\n            this.z2 = this.z2.scale(1/norm);\n        }\n    }\n\n    is_zero(eps) {\n        return this.z1.is_zero(eps);\n    }\n    \n    is_inf(eps) {\n        return this.z2.is_zero(eps);\n    }\n\n    static of_complex(z) {\n        return new CP1(z);\n    }\n\n    static of_real(r) {\n        return CP1.of_complex(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.of_real(r));\n    }\n    \n    static of_xy(x, y) {\n        return CP1.of_complex(new _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n    }\n    \n    static get inf() {\n        return inf;\n    }\n    \n    static get zero() {\n        return zero;\n    }\n    \n    static get one() {\n        return one;\n    }\n\n    to_complex() {\n        return this.z1.div(this.z2);\n    }\n    \n    add(other) {\n        if (!this.z2.is_zero() || !other.z2.is_zero())\n            return new CP1(this.z1.mult(other.z2).add(other.z1.mult(this.z2)),\n                           this.z2.mult(other.z2));\n        else\n            return CP1.inf;\n    }\n\n    uminus() {\n        return new CP1(this.z1.uminus(), this.z2);\n    }\n\n    sub(other) {\n        return this.add(other.uminus());\n    }\n\n    mult(other) {\n        if ((this.z1.is_zero() && other.z2.is_zero()) ||\n            (other.z1.is_zero() && this.z2.is_zero))\n            return CP1.one();\n        else\n            return new CP1(this.z1.mult(other.z1), this.z2.mult(other.z2));\n    }\n\n    reciprocal() {\n        return new CP1(this.z2, this.z1);\n    }\n\n    div(other) {\n        return this.mult(other.reciprocal());\n    }\n\n    conjugate() {\n        return new CP1(this.z1.cnj(), this.z2.cnj());\n    }\n\n    inversion() {\n        return this.reciprocal().conjugate();\n    }\n\n    eq(other) {\n        return this.sub(other).is_zero();\n    }\n\n    clone() {\n        return new CP1(this.z1.clone(), this.z2.clone());\n    }\n\n    static ratio(a, b, c) {\n        return (a.sub(b)).div(a.sub(c));\n    }\n\n    static cross_ratio(z, u, v, w) {\n        const n1 = z.z1.mult(u.z2).sub(u.z1.mult(z.z2));\n        const n2 = v.z1.mult(w.z2).sub(w.z1.mult(v.z2));\n        const d1 = z.z1.mult(w.z2).sub(w.z1.mult(z.z2));\n        const d2 = v.z1.mult(u.z2).sub(u.z1.mult(v.z2));\n        if (!n1.mult(n2).is_zero() || !d1.mult(d2).is_zero())\n            return new CP1(n1.mult(n2), d1.mult(d2));\n        else\n            return CP1.one();\n    }\n\n    vec_mult(other) {\n        return this.z1.mult(other.z1).add(this.z2.mult(other.z2));\n    }\n}\n\nconst inf  = new CP1(_complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.one, _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex.zero);\nconst zero = CP1.of_real(0);\nconst one  = CP1.of_real(1);\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/complex_geom/cp1.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/complex_geom/moebius.js":
/*!*********************************************************!*\
  !*** ./node_modules/ArgoDG/src/complex_geom/moebius.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Moebius\": () => (/* binding */ Moebius)\n/* harmony export */ });\n/* harmony import */ var _complex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex.js */ \"./node_modules/ArgoDG/src/complex_geom/complex.js\");\n/* harmony import */ var _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complex_matrix.js */ \"./node_modules/ArgoDG/src/complex_geom/complex_matrix.js\");\n/* harmony import */ var _circline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circline.js */ \"./node_modules/ArgoDG/src/complex_geom/circline.js\");\n\n\n\n\n/**\n * Moebius transform (az + b) / (cz + d) acting on points of CP1\n */\nclass Moebius {\n    constructor(A, B, C, D) {\n        if (arguments.length == 1 && A instanceof _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2) {\n            this.construct(A.A, A.B, A.C, A.D);\n        } else {\n            this.construct(A, B, C, D);\n        }\n    }\n\n    construct(A, B, C, D) {\n        if (!A.is_zero()) {\n            B = B.div(A);\n            C = C.div(A);\n            D = D.div(A);\n            A = A.div(A); // must be last\n        }\n        else {\n            const b = B.norm();\n            A = A.scale(1 / b);\n            B = B.scale(1 / b);\n            C = C.scale(1 / b);\n            D = D.scale(1 / b);\n        }\n        this.M = new _complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2(A, B, C, D);\n    }\n\n    moebius_pt(z) {\n        if (z instanceof _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex)\n            z = CP1.of_complex(z);\n        return this.M.multCP1(z);\n    }\n\n    moebius_inv_pt(z) {\n        if (z instanceof _complex_js__WEBPACK_IMPORTED_MODULE_0__.Complex)\n            z = CP1.of_complex(z);\n        return this.M.multInvCP1(z);\n    }\n\n    moebius_circline(c) {\n        return new _circline_js__WEBPACK_IMPORTED_MODULE_2__.Circline(c.H.congruence(this.M.inv()));\n    }\n\n    static id() {\n        return new Moebius(_complex_matrix_js__WEBPACK_IMPORTED_MODULE_1__.ComplexMatrix2x2.eye());\n    }\n\n    inv() {\n        return new Moebius(this.M.inv());\n    }\n\n    comp(other) {\n        return new Moebius(this.M.multM(other.M));\n    }\n\n    static moebius_01inf(w1, w2, w3) {\n        const m23 = w2.z1.mult(w3.z2).sub(w3.z1.mult(w2.z2));\n        const m21 = w2.z1.mult(w1.z2).sub(w1.z1.mult(w2.z2));\n        const m13 = w1.z1.mult(w3.z2).sub(w3.z1.mult(w1.z2));\n        return new Moebius(w1.z2.mult(m23), w1.z1.mult(m23).uminus(),\n                           w3.z2.mult(m21), w3.z1.mult(m21).uminus());\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/complex_geom/moebius.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/animation_buttons.js":
/*!*********************************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/animation_buttons.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationButtons\": () => (/* binding */ AnimationButtons)\n/* harmony export */ });\nclass AnimationButtons {\n    constructor(construction, element) {\n        const divBtns = document.createElement(\"div\");\n        element.appendChild(divBtns);\n        \n        const btnPrev = document.createElement(\"button\");\n        btnPrev.innerHTML = \"<<\";\n        btnPrev.addEventListener(\"click\", construction.prevAnimationStep.bind(construction));\n        divBtns.appendChild(btnPrev);\n        \n        const btnNext = document.createElement(\"button\");\n        btnNext.innerHTML = \">>\";\n        btnNext.addEventListener(\"click\", construction.nextAnimationStep.bind(construction));\n        divBtns.append(btnNext);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/animation_buttons.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/canvas.js":
/*!**********************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/canvas.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas)\n/* harmony export */ });\n/* harmony import */ var _latex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./latex.js */ \"./node_modules/ArgoDG/src/dg/latex.js\");\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors.js */ \"./node_modules/ArgoDG/src/dg/colors.js\");\n\n\n\n// -----------------------------------------------------------------------------\n// encapsulate drawing canvas with a few basic drawing primitives\n// -----------------------------------------------------------------------------\nclass Canvas {\n    constructor(element, options) {\n        if (typeof element == \"string\")\n            element = document.getElementById(element);\n\n        if (element instanceof HTMLCanvasElement) {\n            this._canvas = element;\n            this._container = document.createElement(\"div\");\n            this._canvas.parentNode.replaceChild(this._container, this._canvas);\n            this._container.append(this._canvas);\n            this._container.style.width = \"500px\";\n            const h1 = document.getElementsByTagName(\"h1\")[0];\n            h1.style.textAlign = \"center\";\n            h1.style.marginTop = \"45px\";\n        } else {\n            this._container = element;\n            this._canvas = document.createElement(\"canvas\");\n            this._container.append(this._canvas);\n            this._canvas.width = this._container.width;\n            this._canvas.height = this._container.height;\n        }\n\n        this._container.style.marginLeft = \"auto\";\n        this._container.style.marginRight = \"auto\";\n\n        const ratio = window.devicePixelRatio;\n        \n        if (options.width) {\n            this._canvas.width = options.width * ratio;\n            this._canvas.style.width = options.width + \"px\";\n        }\n\n        if (options.height) {\n            this._canvas.height = options.height * ratio;\n            this._canvas.style.height = options.height + \"px\";\n        }\n\n        this._canvas.getContext(\"2d\").scale(ratio, ratio);\n        \n        if (options.border)\n            this._canvas.style.border = options.border;\n\n        this._defaultColor = \"black\";\n        this._defaultWidth = 1;\n        this._defaultDash = [];\n\n        // add status line paragraph\n        const p = document.createElement(\"p\");;\n        this._p_status = p;\n        const divContainer = document.createElement(\"div\");\n        this._canvas.parentNode.replaceChild(divContainer, this._canvas);\n        divContainer.style.position = \"relative\";\n        divContainer.append(this._canvas);\n        divContainer.append(p);\n        p.style.position = \"absolute\";\n        p.style.top = \"0px\";\n        p.style.left = \"0px\";\n        p.style.margin = \"5px\";\n        p.style.backgroundColor = \"white\";\n    }\n\n    canvas() {\n        return this._canvas;\n    }\n    \n    container() {\n        return this._container;\n    }\n\n    addEventListener(event, fun) {\n        this._canvas.addEventListener(event, fun);\n    }\n\n    width() {\n        const ratio = window.devicePixelRatio;\n        return this._canvas.width / ratio;\n    }\n\n    height() {\n        const ratio = window.devicePixelRatio;\n        return this._canvas.height / ratio;\n    }\n\n    context() {\n        return this._canvas.getContext(\"2d\");\n    }\n\n    clear() {\n        const ctx = this.context();\n        ctx.clearRect(0, 0, this.width(), this.height());\n    }\n\n    arc(x, y, r, angle_from, angle_to, color, width, dash, fill) {\n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        if (fill === undefined)\n            fill = false;\n        \n        const ctx = this.context();\n        ctx.lineWidth = width;\n        ctx.setLineDash(dash);\n        ctx.beginPath();\n        ctx.arc(x, y, r, angle_from, angle_to, true);\n        if (fill) {\n            ctx.fillStyle = color;\n            ctx.fill();\n            const o = (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(color)\n            if (!o)\n                ctx.strokeStyle = \"black\";\n            else\n                ctx.strokeStyle = \"rgba(0, 0, 0, \" + o + \")\";\n            ctx.stroke();\n        } else {\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        }\n    }\n    \n    circle(x, y, r, color, width, dash, fill) {\n        this.arc(x, y, r, 0, 2*Math.PI, color, width, dash, fill);\n    }\n\n    segment(x1, y1, x2, y2, color, width, dash) {\n        color = color || this._defaultColor;\n        width = width || this._defaultWidth;\n        dash = dash || this._defaultDash;\n        const ctx = this.context();\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.lineWidth = width;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(dash);\n        ctx.stroke();\n    }\n\n    line_endpoints(x1, y1, x2, y2) {\n        const [w, h] = [this.width(), this.height()];\n\n        if (x1 == x2)\n            return [x1, 0, x1, h];\n        else if (y1 == y2)\n            return [0, y1, w, y1];\n        else {\n            let result = []\n\n            function point(t) {\n                const x = x1 + t * (x2 - x1);\n                const y = y1 + t * (y2 - y1);\n                return [x, y];\n            }\n\n            let t, x, y;\n            \n            t = (0 - x1) / (x2 - x1);\n            [x, y] = point(t);\n\n            if (0 <= y && y <= h)\n                result.push.apply(result, [x, y]);\n\n            t = (w - x1) / (x2 - x1);\n            [x, y] = point(t);\n\n            if (0 <= y && y <= h)\n                result.push.apply(result, [x, y]);\n\n            if (result.length == 4)\n                return result;\n\n            t = (0 - y1) / (y2 - y1);\n            [x, y] = point(t);\n\n            if (0 <= x && x <= w)\n                result.push.apply(result, [x, y]);\n            \n            if (result.length == 4)\n                return result;\n            \n            t = (h - y1) / (y2 - y1);\n            [x, y] = point(t);\n\n            if (0 <= x && x <= w)\n                result.push.apply(result, [x, y]);\n\n            return result;\n        }\n    }\n\n    line(x1, y1, x2, y2, color, width, dash) {\n        const [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2);\n        this.segment(x1l, y1l, x2l, y2l, color, width, dash);\n    }\n\n    line_label(x1, y1, x2, y2, color, label) {\n        let [x1l, y1l, x2l, y2l] = this.line_endpoints(x1, y1, x2, y2).map(x => Math.round(x));\n        if (y1l > y2l)\n            [x1l, y1l] = [x2l, y2l];\n\n\n        const offset = 15;\n        let x, y;\n        if (x1l == 0) {\n            x = 0;\n            y = y1l;\n        } else if (x1l == this.width()) {\n            x = this.width() - offset;\n            y = y1l;\n        } if (y1l == 0) {\n            x = x1l;\n            y = offset;\n        } else if (y1l == this.height()) {\n            x = x1l;\n            y = this.height() - offset;\n        }\n        this.text(x, y, label, \"15px Arial\", color);\n    }\n    \n    text(x, y, txt, font, color) {\n        const ctx = this.context();\n        ctx.font = font || \"15px Arial\";\n        \n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = 3;\n        ctx.lineJoin = \"miter\";\n\tctx.miterLimit = 2;\n        ctx.strokeText(txt, x, y);\n        if (color)\n            ctx.fillStyle = color;\n        ctx.fillText(txt, x, y);\n    }\n\n    message(msg) {\n        // this.text(5, 15, msg, \"15px Arial\", \"black\");\n        this._p_status.innerHTML = (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(msg);\n    }\n\n    addMessage(msg) {\n        if (this._p_status.innerHTML)\n            this._p_status.innerHTML += \"<br/>\";\n        this._p_status.innerHTML += (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(msg);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/canvas.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/colors.js":
/*!**********************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/colors.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOpacity\": () => (/* binding */ getOpacity),\n/* harmony export */   \"rgbColor\": () => (/* binding */ rgbColor),\n/* harmony export */   \"setOpacity\": () => (/* binding */ setOpacity)\n/* harmony export */ });\nconst ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\n// convert color in any format to rgb\nfunction rgbColor(str){\n    function hexToRGB(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    function parseRGB(str) {\n        const m = str.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*(\\d+([.]\\d*)?))?\\s*\\)$/i);\n        return m ? {\n            r: m[1],\n            g: m[2],\n            b: m[3]\n        } : null;\n    }\n    \n    ctx.fillStyle = str;\n    const color = ctx.fillStyle;\n    if (color[0] == '#')\n        return hexToRGB(color);\n    else\n        return parseRGB(color);\n}\n\n// extract opacity from color string\nfunction getOpacity(color) {\n    const defaultOpacity = 1;\n    \n    if (!color)\n        return defaultOpacity;\n    const m = color.match(/^rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+([.]\\d*)?)\\s*\\)$/i);\n    return m ? m[4] : defaultOpacity;\n}\n\n// set opacity to color string\nfunction setOpacity(color, o) {\n    const rgb = rgbColor(color);\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + o + \")\";\n}\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/colors.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/construction.js":
/*!****************************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/construction.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Construction\": () => (/* binding */ Construction)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./node_modules/ArgoDG/src/dg/view.js\");\n\n\n/**\n * Construction is a list of DGObjects\n */\nclass Construction {\n    constructor() {\n        this._objects = [];\n        this._views = [];\n        this._animation_step = -1;\n    }\n\n    setView(view) {\n        this._views = [view];\n        view.addConstruction(this);\n    }\n\n    addView(view) {\n        this._views.push(view);\n        view.addConstruction(this);\n    }\n\n    addObject(o, redraw) {\n        if (!o) return;\n        this._objects.push(o);\n        o.addConstruction(this);\n        if (redraw === undefined || redraw)\n            this.draw();\n    }\n\n    removeObject(o, redraw) {\n        if (!o) return;\n        this._objects = this._objects.filter(obj => obj != o);\n        o.removeConstruction(this);\n        if (redraw === undefined || redraw)\n            this.draw();\n    }\n\n    visibleObjects() {\n        let objects = this.animationInProgress() ?\n                      this._objects.slice(0, this._animation_step+1) :\n                      this._objects;\n        return objects.filter(obj => obj.visible());\n    }\n\n    drawView(view) {\n        view.drawObjects(this.visibleObjects());\n        if (this.animationInProgress()) {\n            const currentAnimationObject = this._objects[this._animation_step];\n            view.message(currentAnimationObject.describe());\n        }\n    }\n\n    draw() {\n        this._views.forEach(view => {\n            view.redraw();\n        });            \n    }\n\n    animationInProgress() {\n        return this._animation_step != -1;\n    }\n\n    doAnimationStep(increment) {\n        do {\n            const n = this._objects.length;\n            this._animation_step = (this._animation_step + n + increment) % n;\n        } while (!this._objects[this._animation_step].visible());\n        this.draw();\n    }\n\n    nextAnimationStep() {\n        this.doAnimationStep(+1);\n    }\n    \n    prevAnimationStep() {\n        this.doAnimationStep(-1);\n    }\n    \n    animate() {\n        var self = this;\n        window.setInterval(function() {\n            self.nextAnimationStep();\n            self.drawAnimationStep();\n        }, 1000);\n    }\n\n\n    highlightAt(x, y, worldToScreen, highlighter) {\n        this._objects.forEach(obj => {\n            obj.highlight(obj.isNear(x, y, worldToScreen) && highlighter.shouldHighlight(obj));\n        });\n    }\n\n    findObjectsAt(x, y, worldToScreen) {\n        return this.visibleObjects().filter(p => p.isNear(x, y, worldToScreen));\n    }\n\n    findFreePointAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isFreePoint());\n    }\n    \n    findPointAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isPoint());\n    }\n\n    findLineAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isLine());\n    }\n\n    findCircleAt(x, y, worldToScreen) {\n        return this.findObjectsAt(x, y, worldToScreen).find(o => o.isCircle());\n    }\n\n    find(label) {\n        return this._objects.find(o => o.label() == label);\n    }\n\n    includes(label) {\n        // this can be faster if all object labels are put in a hash-set  \n        return this._objects.some(o => o.label() == label);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/construction.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/dg.js":
/*!******************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/dg.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"If\": () => (/* binding */ If),\n/* harmony export */   \"addObject\": () => (/* binding */ addObject),\n/* harmony export */   \"animate\": () => (/* binding */ animate),\n/* harmony export */   \"animationButtons\": () => (/* binding */ animationButtons),\n/* harmony export */   \"center\": () => (/* binding */ center),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"construction\": () => (/* binding */ construction),\n/* harmony export */   \"constructionToolbar\": () => (/* binding */ constructionToolbar),\n/* harmony export */   \"container\": () => (/* binding */ container),\n/* harmony export */   \"findCircleAt\": () => (/* binding */ findCircleAt),\n/* harmony export */   \"findFreePointAt\": () => (/* binding */ findFreePointAt),\n/* harmony export */   \"findLineAt\": () => (/* binding */ findLineAt),\n/* harmony export */   \"findObjectsAt\": () => (/* binding */ findObjectsAt),\n/* harmony export */   \"findPointAt\": () => (/* binding */ findPointAt),\n/* harmony export */   \"intersectCC_any\": () => (/* binding */ intersectCC_any),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_select\": () => (/* binding */ intersectCC_select),\n/* harmony export */   \"intersectLC_any\": () => (/* binding */ intersectLC_any),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_select\": () => (/* binding */ intersectLC_select),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"nextAnimationStep\": () => (/* binding */ nextAnimationStep),\n/* harmony export */   \"poincareCircle\": () => (/* binding */ poincareCircle),\n/* harmony export */   \"poincareLine\": () => (/* binding */ poincareLine),\n/* harmony export */   \"point\": () => (/* binding */ point),\n/* harmony export */   \"prevAnimationStep\": () => (/* binding */ prevAnimationStep),\n/* harmony export */   \"randomPoint\": () => (/* binding */ randomPoint),\n/* harmony export */   \"randomPointOnCircle\": () => (/* binding */ randomPointOnCircle),\n/* harmony export */   \"randomPointOnLine\": () => (/* binding */ randomPointOnLine),\n/* harmony export */   \"segment\": () => (/* binding */ segment),\n/* harmony export */   \"setConstruction\": () => (/* binding */ setConstruction),\n/* harmony export */   \"setup\": () => (/* binding */ setup),\n/* harmony export */   \"view\": () => (/* binding */ view)\n/* harmony export */ });\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects.js */ \"./node_modules/ArgoDG/src/dg/objects.js\");\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view.js */ \"./node_modules/ArgoDG/src/dg/view.js\");\n/* harmony import */ var _construction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./construction.js */ \"./node_modules/ArgoDG/src/dg/construction.js\");\n/* harmony import */ var _animation_buttons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./animation_buttons.js */ \"./node_modules/ArgoDG/src/dg/animation_buttons.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tool.js */ \"./node_modules/ArgoDG/src/dg/tool.js\");\n\n\n\n\n\n\n// -----------------------------------------------------------------------------\n// API and a global register of all DGobjects\n// -----------------------------------------------------------------------------\n\nlet _global_construction = null;\nlet _global_view = null;\n\n// current construction and view (either global or provided by the user)\nlet _construction;\nlet _view;\n\nlet _animation_buttons = null;\nlet _construction_toolbar = null;\n\nfunction setup(element, options, xmin, xmax, ymin, ymax) {\n    if (arguments.length == 2)\n        _global_view = new _view_js__WEBPACK_IMPORTED_MODULE_1__.View(element, options);\n    else\n        _global_view = new _view_js__WEBPACK_IMPORTED_MODULE_1__.View(element, options, xmin, xmax, ymin, ymax);\n    _global_construction = new _construction_js__WEBPACK_IMPORTED_MODULE_2__.Construction()\n\n    _construction = _global_construction;\n    _view = _global_view;\n    \n    _construction.setView(_view);\n    _view.setTool(new _tool_js__WEBPACK_IMPORTED_MODULE_4__.ToolDragFree(_view, _construction));\n}\n\nfunction setConstruction(construction) {\n    _construction = construction ? construction : _global_construction;\n    _construction.setView(_view);\n    _view.setConstruction(_construction);\n    _view.setTool(new _tool_js__WEBPACK_IMPORTED_MODULE_4__.ToolDragFree(_view, _construction));\n}\n\nfunction construction() {\n    return _construction;\n}\n\nfunction view() {\n    return _view;\n}\n\nfunction container() {\n    return this.view().canvas().container();\n}\n\nfunction addObject(o, redraw) {\n    _construction.addObject(o, redraw);\n}\n\nfunction point(x, y, validity_check) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoint(x, y);\n    if (validity_check)\n        p.validityCheck(validity_check);\n    addObject(p);\n    return p;\n}\n\nfunction randomPoint(redraw, validity_check, xmin, xmax, ymin, ymax) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGRandomPoint(validity_check, xmin, xmax, ymin, ymax);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPointOnCircline(cl, redraw, validity_check, disc) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGRandomPointOnCircline(cl, {\"validity_check\": validity_check, \"disc\": disc});\n    addObject(p, redraw);\n    return p;\n}\n\nfunction randomPointOnLine(line, redraw, validity_check, disc) {\n    return randomPointOnCircline(line, redraw, validity_check, disc);\n}\n\nfunction randomPointOnCircle(circle, redraw, validity_check, disc) {\n    return randomPointOnCircline(circle, redraw, validity_check, disc);\n}\n\n\nfunction line(P1, P2) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGLine(P1, P2);\n    addObject(l);\n    return l;\n}\n\nfunction circle(C, P, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGCircle(C, P);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction intersectLL(l1, l2, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectLL(l1, l2);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC(l, c, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectLC(l, c);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC_both(l, c, redraw) {\n    const i = intersectLC(l, c, redraw);\n    const [p1, p2] = i.both();\n    addObject(p1, false);\n    addObject(p2, redraw);\n    return [p1, p2];\n}\n\nfunction intersectLC_any(l, c, redraw) {\n    const i = intersectLC(l, c, redraw);\n    const p = i.any();\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectLC_select(l, c, select_fun, redraw) {\n    const i = intersectLC(l, c, redraw);\n    const p = i.select(select_fun);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC(c1, c2, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIntersectCC(c1, c2);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC_both(c1, c2, redraw) {\n    const i = intersectCC(c1, c2, redraw);\n    const [p1, p2] = i.both();\n    addObject(p1, false);\n    addObject(p2, redraw);\n    return [p1, p2];\n}\n\nfunction intersectCC_any(c1, c2, redraw) {\n    const i = intersectCC(c1, c2, redraw);\n    const p = i.any();\n    addObject(p, redraw);\n    return p;\n}\n\nfunction intersectCC_select(c1, c2, select_fun, redraw) {\n    const i = intersectCC(c1, c2, redraw);\n    const p = i.select(select_fun);\n    addObject(p, redraw);\n    return p;\n}\n\n\nfunction clone(obj, redraw) {\n    const c = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGClone(obj);\n    addObject(c, redraw);\n    return c;\n}\n\nfunction If(cond, then_object, else_object, dependencies, redraw) {\n    const p = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGIf(cond, then_object, else_object, dependencies);\n    addObject(p, redraw);\n    return p;\n}\n\nfunction center(c, redraw) {\n    const cc = c.center();\n    addObject(cc, redraw);\n    return cc;\n}\n\nfunction poincareLine(p1, p2, redraw) {\n    const l = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareLine(p1, p2);\n    addObject(l, redraw);\n    return l;\n}\n\nfunction poincareCircle(c, p, redraw) {\n    const pc = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGPoincareCircle(c, p);\n    addObject(pc, redraw);\n    return pc;\n}\n\nfunction segment(p1, p2, redraw) {\n    const s = new _objects_js__WEBPACK_IMPORTED_MODULE_0__.DGSegment(p1, p2);\n    addObject(s, redraw);\n    return s;\n}\n\nfunction findFreePointAt(x, y, transform) {\n    return _construction.findFreePointAt(x, y, transform);\n}\n    \nfunction findPointAt(x, y, transform) {\n    return _construction.findPointAt(x, y, transform);\n}\n\nfunction findLineAt(x, y, transform) {\n    return _construction.findLineAt(x, y, transform);\n}\n\nfunction findCircleAt(x, y, transform) {\n    return _construction.findCircleAt(x, y, transform);\n}\n\nfunction findObjectsAt(x, y, transform) {\n    return _construction.findObjectsAt(x, y, transform);\n}\n\nfunction nextAnimationStep() {\n    _construction.nextAnimationStep();\n}\n\nfunction prevAnimationStep() {\n    _construction.prevAnimationStep();\n}\n\nfunction animate() {\n    _construction.animate();\n}\n\nfunction animationButtons() {\n    if (!_animation_buttons)\n        _animation_buttons = new _animation_buttons_js__WEBPACK_IMPORTED_MODULE_3__.AnimationButtons(_construction, _view.canvas().container());\n}\n\nfunction constructionToolbar() {\n    if (!_construction_toolbar)\n        _construction_toolbar = new _tool_js__WEBPACK_IMPORTED_MODULE_4__.ConstructionToolbar(_construction, _view, _view.canvas().container());\n}\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/dg.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/latex.js":
/*!*********************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/latex.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"laTeX2HTML\": () => (/* binding */ laTeX2HTML),\n/* harmony export */   \"normalizeBraces\": () => (/* binding */ normalizeBraces),\n/* harmony export */   \"removeLaTeX\": () => (/* binding */ removeLaTeX)\n/* harmony export */ });\nfunction normalizeBraces(str) {\n    return str ? str.replace(/([\\w'()]+)_(\\w)/g, '$1_{$2}') : \"\";\n}\n\nfunction laTeX2HTML(str) {\n    return str ? normalizeBraces(str).replace(/([\\w'()]+)_{(\\w+)}/g, '$1<sub>$2</sub>') : \"\";\n}\n\nfunction removeLaTeX(str) {\n    return str ? normalizeBraces(str).replace(/([\\w'()]+)_{(\\w+)}/g, '$1$2') : \"\";\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/latex.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/objects.js":
/*!***********************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/objects.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DGCircle\": () => (/* binding */ DGCircle),\n/* harmony export */   \"DGCircleCenterPoint\": () => (/* binding */ DGCircleCenterPoint),\n/* harmony export */   \"DGClone\": () => (/* binding */ DGClone),\n/* harmony export */   \"DGIf\": () => (/* binding */ DGIf),\n/* harmony export */   \"DGIntersectCC\": () => (/* binding */ DGIntersectCC),\n/* harmony export */   \"DGIntersectLC\": () => (/* binding */ DGIntersectLC),\n/* harmony export */   \"DGIntersectLL\": () => (/* binding */ DGIntersectLL),\n/* harmony export */   \"DGLine\": () => (/* binding */ DGLine),\n/* harmony export */   \"DGPoincareCircle\": () => (/* binding */ DGPoincareCircle),\n/* harmony export */   \"DGPoincareLine\": () => (/* binding */ DGPoincareLine),\n/* harmony export */   \"DGPoint\": () => (/* binding */ DGPoint),\n/* harmony export */   \"DGRandomPoint\": () => (/* binding */ DGRandomPoint),\n/* harmony export */   \"DGRandomPointOnCircline\": () => (/* binding */ DGRandomPointOnCircline),\n/* harmony export */   \"DGSegment\": () => (/* binding */ DGSegment)\n/* harmony export */ });\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../complex_geom.js */ \"./node_modules/ArgoDG/src/complex_geom.js\");\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors.js */ \"./node_modules/ArgoDG/src/dg/colors.js\");\n\n\n\n// -----------------------------------------------------------------------------\n// the base class for all geometric objects\n// -----------------------------------------------------------------------------\nclass DGObject {\n    // global number of created objects\n    static num_objects = 0;\n    \n    constructor(construction) {\n        // unique object identifier\n        this._ID = DGObject.num_objects++;\n        \n        // objects dependent on the current one (the ones constructed\n        // using this object)\n        this._dependent_objects = [];\n\n        // some objects can be invalid (e.g., intersection point\n        // selected by some given criteria, when no selection point exists)\n        this._valid = true;\n\n        // style (visibility, color, width, size, dashed, ...)\n        this._style = {};\n\n        // no object is highlighted by default\n        this._style._highlight = false;\n\n        // each object can be a part of one or more constructions\n        this._constructions = [];\n        if (construction)\n            this.addConstruction(construction);\n    }\n\n    addConstruction(construction) {\n        this._constructions.push(construction);\n    }\n\n    removeConstruction(construction) {\n        this._constructions = this._constructions.filter(c => c != construction);\n    }\n\n    type() {\n        return \"object\";\n    }\n\n    isFreePoint() {\n        return false;\n    }\n\n    isPoint() {\n        return false;\n    }\n\n    isLine() {\n        return false;\n    }\n\n    isCircle() {\n        return false;\n    }\n\n    // fire event that this object has changed\n    fireChangeEvent() {\n        // redraw constructions where this object occurs\n        this._constructions.forEach(construction => {\n            construction.draw();\n        });\n    }\n    \n    // set if this object should be visible\n    show(yes, redraw) {\n        if (yes == undefined)\n            yes = true;\n        this._style._hide = !yes;\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // set that this object should not be visible\n    hide(redraw) {\n        this.show(false, redraw);\n        return this;\n    }\n\n    // check if the object is hidden (not visible)\n    hidden() {\n        return this._style._hide;\n    }\n\n    // check if the object is visible (not hidden)\n    visible() {\n        return !this.hidden();\n    }\n\n    // get or set the color of the object\n    color(c, redraw) {\n        // if c is undefined get the color\n        if (c === undefined)\n            // return color that has been set or black otherwise\n            return this._style._color ? this._style._color : \"black\";\n\n        // otherwise set the color\n        this._style._color = c;\n\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // get or set the line width of the object\n    width(w, redraw) {\n        // w is undefined get the width\n        if (w === undefined)\n            // return width that has been set or 1 if it is undefined\n            return this._style._width ? this._style._width : 1;\n\n        // otherwise set the width\n        this._style._width = w;\n        \n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // set dashed pattern\n    dashed(redraw) {\n        this._style._dash = [8, 4];\n        \n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // set solid line\n    solid(redraw) {\n        this._style._dash = [];\n        \n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // get the dash pattern\n    dash() {\n        return this._style._dash ? this._style._dash : [];\n    }\n\n    // get or set opacity of the object\n    opacity(o, redraw) {\n        // o is undefined get the opacity\n        if (o === undefined)\n            return (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(this.color());\n        \n        // otherwise set the opacity\n        this.color((0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), o));\n        \n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // get or set the size of the object (for drawing points)\n    size(s, redraw) {\n        // if s is undefined get the size\n        if (s === undefined)\n            // return size that has been set or 1 if it is undefined\n            return this._style._size ? this._style._size : 1;\n\n        // otherwise set the size\n        this._style._size = s;\n\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // default label for the object (if label is not set)\n    defaultLabel() {\n        return this.type() + \"(\" + this._ID + \")\";\n    }\n\n    // default description for the object (if description is not set)\n    defaultDescription() {\n        return \"\";\n    }\n\n    // get/set the label of the object\n    label(str, show, redraw) {\n        // str is undefined get the label\n        if (str === undefined) {\n            if (this._style._label)\n                return this._style._label;\n            // label is not set - get the default label\n            return this.defaultLabel();\n        }\n        \n        // otherwise set the label\n        this._style._label = str;\n\n        // label should be shown unless showing it explicitly turned off\n        this._style._showing_label = show == undefined || show;\n\n        // change (redraw) event is fired unless that is explicitly turned off\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // does this object have a non-generic label\n    hasLabel() {\n        return this._style._label !== undefined;\n    }\n\n    // check if the label should be shown\n    showingLabel() {\n        return this._style._showing_label;\n    }\n\n    // get or set the description\n    description(desc, redraw) {\n        if (desc != undefined) {\n            // if description is given, set the description\n            this._style._description = desc;\n            \n            if (redraw === undefined || redraw)\n                this.fireChangeEvent();\n            return this;\n        } else {\n            // otherwise get the description\n            if (this._style._description)\n                return this._style._description;\n            // description is not set - get the default description\n            return this.defaultDescription();\n        }\n    }\n\n    // append string to the existing description\n    addDescription(desc, redraw) {\n        this._style._description += desc;\n        \n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n    }\n\n    // returns a nice description for the object that might contain a label (if its given)\n    // and description (given or default)\n    describe() {\n        let result;\n        if (this.hasLabel()) {\n            result = this.label();\n            if (this.description())\n                result += \": \" + this.description();\n        } else {\n            if (this.description())\n                result = this.description();\n            else\n                result = this.label();\n        }\n        return result;\n    }\n\n    // get or set highlight (that shows that mouse is on the object) \n    highlight(h, redraw) {\n        if (h === undefined)\n            return this._style._highlight ? this._style._highlight : false;\n\n        if (h != this._style._highlight) {\n            this._style._highlight = h;\n            if (redraw === undefined || redraw)\n                this.fireChangeEvent();\n        }\n    }\n\n    // get or set the entire style object\n    style(st, redraw) {\n        if (st === undefined)\n            return this._style;\n        \n        this._style = st;\n        \n        // change (redraw) event is fired unless that is explicitly turned off\n        if (redraw === undefined || redraw)\n            this.fireChangeEvent();\n        return this;\n        \n    }\n\n    // draw object on the given View\n    // this is a template method and the real drawing is done within\n    // the polimorphic drawMe method\n    draw(view) {\n        if (this.hidden())\n            return;\n        if (!this._valid)\n            return;\n        this.drawMe(view);\n        if (this.showingLabel())\n            this.drawLabel(view);\n    }\n\n    // this should be overridden\n    drawMe(view) {\n    }\n\n    // this should be overridden\n    drawLabel(view) {\n    }\n    \n    // Register a DGObject to depend on the current object, so that it\n    // is updated whenever the current object changes\n    addDependent(o) {\n        this._dependent_objects.push(o);\n    }\n\n    // Recaculate the position of all dependent objects when this object changes\n    // this is a template method that handles the order of\n    // recalculations, while the coordinate calculations happen within\n    // the polimorphic recalceMe method\n    recalc() {\n        // a topological sort is performed to determine the optimal\n        // order of recalculation of dependent objects\n\n        // first a BFS traversal is used to calculate the number of objects that \n        // each relevant object depends on (its degree)\n        \n        let queue = [];\n        const n = DGObject.num_objects;\n        const degree = new Array(n).fill(0);\n        const objects = new Array(n).fill(null);\n        \n        function enqueue(obj) {\n            degree[obj._ID]++;\n            if (objects[obj._ID] == null) {\n                objects[obj._ID] = obj;\n                queue.push(obj);\n            }\n        }\n\n        objects[this._ID] = this;\n        this._dependent_objects.forEach(enqueue);\n        while (queue.length > 0) {\n            const obj = queue.shift();\n            obj._dependent_objects.forEach(enqueue);\n        }\n\n        // next the Kahn's algoritm is performed\n        queue = [this._ID];\n        while (queue.length > 0) {\n            const id = queue.shift();\n            objects[id].recalcMe();\n            objects[id]._dependent_objects.forEach(obj => {\n                if (--degree[obj._ID] == 0)\n                    queue.push(obj._ID);\n            });\n        }\n    }\n\n    // this should be overridden\n    recalcMe() {\n    }\n\n    // check if two objects are equal\n    eq(other) {\n        if (this.isPoint() && other.isPoint()) {\n            return this.cp1().eq(other.cp1());\n        }\n        if (this instanceof DGCircline && other instanceof DGCircline) {\n            return this.circline().eq(other.circline())\n        }\n        return false;\n    }\n\n    // clone\n    clone() {\n        return new DGClone(this);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// clone - shallow copy of object that can have its own style and visibility\n// -----------------------------------------------------------------------------\n\nclass DGClone extends DGObject {\n    constructor(object) {\n        super();\n        \n        this._object = object;\n        this._style = {...this._object.style()};\n        return new Proxy(this, this);\n    }\n\n    type() {\n        return \"clone\";\n    }\n\n    drawMe(view) {\n        const old_style = this._object.style();\n        this._object.style(this._style, false);\n        this._object.drawMe(view);\n        this._object.style(old_style, false);\n    }\n\n    drawLabel(view) {\n        const old_style = this._object.style();\n        this._object.style(this._style, false);\n        this._object.drawLabel(view);\n        this._object.style(old_style, false);\n    }\n\n    isPoint() {\n        return this._object.isPoint();\n    }\n\n    get(target, prop) {\n        return this[prop] || this._object[prop];\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// free point\n// -----------------------------------------------------------------------------\n// the point is internally represented by a CP1 object\nclass DGPoint extends DGObject {\n    constructor(x, y) {\n        super();\n        \n        this._validity_check = undefined;\n        if (arguments.length == 2)\n            this._valid = this.moveTo(x, y);\n\n        return this;\n    }\n\n    type() {\n        return \"point\";\n    }\n\n    // fix the point so that it cannot be moved\n    fix() {\n        this._fixed = true;\n        return this;\n    }\n\n    // free the point so that it can be moved\n    free() {\n        this._fixed = false;\n        return this;\n    }\n\n    // this is the only class that defines free points (points that\n    // can be moved by using the mouse, unless they are fixed)\n    isFreePoint() {\n        if (this._fixed)\n            return false;\n        return true;\n    }\n\n    // this object is a point\n    isPoint() {\n        return true;\n    }\n\n    // user can constrain this point to satisfy some criteria defined\n    // by the function fun cp1 -> bool\n    validityCheck(fun) {\n        this._validity_check = fun;\n        return this;\n    }\n\n    // trying to move the point to the given position\n    // moving is not allowed if the target position does not satisfy\n    // the validity check\n    moveTo(x, y) {\n        if (this._validity_check == undefined || this._validity_check(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_xy(x, y))) {\n            // update the internal CP1 object\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n            // update all dependent objects\n            this.recalc();\n\n            this.fireChangeEvent();\n            // the point was successfully moved\n            return true;\n        }\n        // the point could not be moved\n        return false;\n    }\n\n    // theoretically, the point can be infinite\n    is_inf() {\n        return this._coords.is_inf();\n    }\n\n    // conversion to complex number (unless infinite)\n    to_complex() {\n        return this._coords.to_complex();\n    }\n\n    // x coordinate (unless infinite)\n    x() {\n        const c = this.to_complex();\n        return c.re;\n    }\n\n    // y coordinate (unless infinite)\n    y() {\n        const c = this.to_complex();\n        return c.im;\n    }\n    \n    // both coordinates (unless infinite)\n    coords() {\n        const c = this.to_complex();\n        return [c.re, c.im];\n    }\n\n    // internal cp1 representation\n    cp1() {\n        return this._coords;\n    }\n\n    // check equality of two points\n    eq(other) {\n        if (other instanceof _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1)\n            return this.cp1().eq(other);\n        if (other.isPoint()) {\n            return this.cp1().eq(other.cp1());\n        }\n        return false;\n    }\n\n    // distance to the other point (unless one of them is infinite)\n    distance(other) {\n        return this.to_complex().sub(other.to_complex()).norm();\n    }\n\n    // check if this point is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        const [xt, yt] = worldToScreen(this.x(), this.y());\n        const dist2 = (xt - x)*(xt - x) + (yt - y)*(yt - y);\n        let EPS = 5;\n        EPS *= this.size();\n        return dist2 <= EPS * EPS;\n    }\n\n    // drawing the point on the given View\n    drawMe(view) {\n        if (!this.is_inf()) {\n            if (this.highlight()) {\n                view.point(this.x(), this.y(), {color: (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), 0.5*this.opacity()), size: 1.5*this.size()});\n            }\n            view.point(this.x(), this.y(), {color: this.color(), size: this.size()});\n            \n        }\n    }\n\n    // drawing the point label on the given View \n    drawLabel(view) {\n        if (!this.is_inf() && this._style._label)\n            view.text(this.x(), this.y(), this._style._label);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// random point\n// -----------------------------------------------------------------------------\nclass DGRandomPoint extends DGPoint {\n    constructor(validity_check, xmin, xmax, ymin, ymax) {\n        super();\n        \n        xmin = xmin || -1;\n        xmax = xmax || 1;\n        ymin = ymin || -1;\n        ymax = ymax || 1;\n        this._xmin = xmin; this._xmax = xmax;\n        this._ymin = ymin; this._ymax = ymax;\n        this._validity_check = validity_check ? validity_check : (p => true);\n        this.recalcMe();\n    }\n\n    type() {\n        return \"random point\";\n    }\n    \n    // random point is not free\n    isFreePoint() {\n        return false;\n    }\n\n    recalcMe() {\n        const MAX_ITER = 100;\n        let x, y;\n        let i = 0;\n        do {\n            x = this._xmin + Math.random() * (this._xmax - this._xmin);\n            y = this._ymin + Math.random() * (this._ymax - this._ymin);\n            this._coords = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y));\n            i++;\n        } while (!this._validity_check(this._coords) && i < MAX_ITER);\n        if (i == MAX_ITER)\n            throw \"Could not generate valid random point\";\n    }\n}\n\n// -----------------------------------------------------------------------------\n// joint class for circles and lines\n// -----------------------------------------------------------------------------\n\nclass DGCircline extends DGObject {\n    constructor() {\n        super();\n    }\n\n    type() {\n        return \"circline\";\n    }\n\n    drawMe(view) {\n        function doDraw(cl, style) {\n            if (cl._circline.is_line()) {\n                const [p1, p2] = cl._circline.line_points();\n                const [x1, y1] = [p1.re, p1.im];\n                const [x2, y2] = [p2.re, p2.im];\n                view.line(x1, y1, x2, y2, style);\n            } else {\n                const c = cl._circline.circle_center();\n                const r = cl._circline.circle_radius();\n                const [x, y] = [c.re, c.im];\n                view.circle(x, y, r, style);\n            }\n        }\n        \n        const style = {\n            color: this.color(),\n            width: this.width(),\n            dash: this.dash()\n        };\n        doDraw(this, style);\n        \n        if (this.highlight()) {\n            const style = {\n                color: (0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.setOpacity)(this.color(), 0.5*(0,_colors_js__WEBPACK_IMPORTED_MODULE_1__.getOpacity)(this.color())),\n                width: 3*this.width(),\n                dash: this.dash()\n            };\n            doDraw(this, style);\n        }\n    }\n\n    // drawing the line label on the given View \n    drawLabel(view) {\n        if (this._circline.is_line() && this._style._label) {\n            const [p1, p2] = this._circline.line_points();\n            const [x1, y1] = [p1.re, p1.im];\n            const [x2, y2] = [p2.re, p2.im];\n            view.line_label(x1, y1, x2, y2, this._style._color, this._style._label);\n        }\n    }\n\n    // check if this line is near the given point on the screen\n    // (world-to-screen coordinate transform is given)\n    isNear(x, y, worldToScreen) {\n        return this._circline.transform(worldToScreen).on_circline(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_complex(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y)));\n    }\n    \n    // return internal representation (FIXME: this should be private)\n    circline() {\n        return this._circline;\n    }\n\n    intersect(other) {\n        return this.circline().intersect(other.circline());\n    }\n}\n\n// -----------------------------------------------------------------------------\n// straight line between two given points\n// -----------------------------------------------------------------------------\n// internally the line is represented by a CP1 circline (a Hermitean matrix)\nclass DGLine extends DGCircline {\n    // construct a line given the two points\n    constructor(p1, p2) {\n        super();\n        \n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"line\";\n    }\n\n    defaultDescription() {\n        return \"line \" + this._p1.label() + this._p2.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._p1._valid && this._p2._valid;\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.circline3(this._p1.cp1(), this._p2.cp1(), _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf);\n    }\n\n    // find intersection of two lines (infinite point if the lines are parallel)\n    static intersect(l1, l2) {\n        const p = l1.intersect(l2);\n        if (!p[0].is_inf())\n            return p[0];\n        if (!p[1].is_inf())\n            return p[1];\n        // both points are infinite (lines are parallel)\n        return _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.inf;\n    }\n\n    isLine() {\n        return true;\n    }\n\n    circline() {\n        return this._circline;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a line segment\n// -----------------------------------------------------------------------------\nclass DGSegment extends DGLine {\n    constructor(p1, p2) {\n        super(p1, p2);\n    }\n\n    type() {\n        return \"segment\";\n    }\n\n    defaultDescription() {\n        return \"segment \" + this._p1.label() + this._p2.label();\n    }\n\n    drawMe(view) {\n        const [x1, y1] = this._p1.coords();\n        const [x2, y2] = this._p2.coords();\n        view.segment(x1, y1, x2, y2, {color: this._style._color, width: this._style._width, dash: this._style._dash});\n    }\n\n    // drawing the segment label on the given View \n    drawLabel(view) {\n        // TODO\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a random point on the line\n// -----------------------------------------------------------------------------\nclass DGRandomPointOnCircline extends DGPoint {\n    constructor(l, params) {\n        super();\n        this._line = l;\n        this._validity_check = params.validity_check ? params.validity_check : p => true;\n        this._disc = params.disc;\n        // if the line moves, this point must be updated\n        l.addDependent(this);\n        // initialize (randomly) the point coordinates\n        this.recalcMe();\n        // fix the point so that it cannot be moved\n        this.fix();\n    }\n\n    type() {\n        return \"point on circline\";\n    }\n\n    // point on circline is semi-free\n    isFreePoint() {\n        return !this._fixed;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        const MAX_ITER = 100;\n        this._valid = this._line._valid;\n        let iter = 0;\n        do {\n            if (this._disc)\n                this._coords = this._line.circline().random_point_in_disc(this._disc);\n            else\n                this._coords = this._line.circline().random_point();\n            iter++;\n        } while (!this._validity_check(this._coords) && iter < MAX_ITER);\n        if (iter == MAX_ITER) {\n            this._valid = false;\n            console.log(this._line.circline());\n            throw \"Unable to generate valid random point\";\n        }\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a circle with a given center and point\n// -----------------------------------------------------------------------------\n// internally the line is represented by a CP1 circline (a Hermitean matrix)\nclass DGCircle extends DGCircline {\n    constructor(c, p) {\n        super();\n        \n        this._c = c;\n        this._p = p;\n        // if any of the two points move, this line must be updated\n        c.addDependent(this);\n        p.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"circle\";\n    }\n\n    defaultDescription() {\n        return \"circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n\n    // this is a circle\n    isCircle() {\n        return true;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._c._valid && this._p._valid;\n        this._r = this._c.distance(this._p);\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circle(this._c.to_complex(), this._r);\n    }\n\n    // return the center of the circle\n    center() {\n        return new DGCircleCenterPoint(this);\n    }\n\n    // check if the given CP1 object lies in the current circle disc (boundary excluded)\n    inDisc(p) {\n        return this._circline.in_disc(p);\n    }\n\n    // check if the point (x, y) lies in the current circle disc (boundary excluded)\n    inDiscXY(x, y) {\n        return this._circline.in_disc(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_complex(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y)));\n    }\n\n    // check if the point (x, y) lies on the current circle\n    onCircleXY(x, y) {\n        return this._circline.on_circline(_complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_complex(new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex(x, y)), 1e-3);\n    }\n\n    // intersect a line and a circle\n    static intersectLC(l, c) {\n        return l.intersect(c);\n    }\n\n    // intersect two circles\n    static intersectCC(c1, c2) {\n        return c1.intersect(c2);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// center of the given circle\n// -----------------------------------------------------------------------------\nclass DGCircleCenterPoint extends DGPoint {\n    constructor(c) {\n        super();\n        \n        this._circle = c;\n        // if the circle moves, this point must be updated\n        c.addDependent(this);\n        // initialize center coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"circle center\";\n    }\n\n    // circle center point is not free\n    isFreePoint() {\n        return false;\n    }\n\n    defaultDescription() {\n        return \"center of \" + this._circle.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._circle._valid;\n        this._coords = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.CP1.of_complex(this._circle.circline().circle_center());\n    }\n}\n\n// -----------------------------------------------------------------------------\n// intersection of two lines\n// -----------------------------------------------------------------------------\n// a finte CP1 point, unless lines are parallel\nclass DGIntersectLL extends DGPoint {\n    constructor(l1, l2) {\n        super();\n        \n        this._l1 = l1;\n        this._l2 = l2;\n        // if any of the two line line changes, the intersection must be updated\n        l1.addDependent(this);\n        l2.addDependent(this);\n\n        // initialize the coordinates of the intersection\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersectLL\";\n    }\n\n    defaultDescription() {\n        return \"intersection of \" + this._l1.label() + \" and \" + this._l2.label();\n    }\n\n    // although the intersection is a point, it is not a free point\n    isFreePoint() {\n        return false;\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._l1._valid && this._l2._valid;\n        this._coords = DGLine.intersect(this._l1, this._l2);\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// object that represents the set of all intersection points between two\n// geometric objects (e.g. a line and a circle, or two circles)\n// -----------------------------------------------------------------------------\nclass DGIntersections extends DGObject {\n    constructor() {\n        super();\n        this.hide(false);\n    }\n\n    type() {\n        return \"intersections\";\n    }\n    \n    // creates a single intersection point based on the given\n    // selection criterion cp1 -> bool\n    intersectionPoint(selectionCriterion) {\n        const p = new DGIntersectPoint(this, selectionCriterion, this.description());\n        // if this set of all intersection points changes, then the\n        // single selected intersection point must be updated\n        this.addDependent(p);\n        return p;\n    }\n\n    // return any intersection point\n    any() {\n        return this.intersectionPoint(p => true);\n    }\n\n    // return both intersection points\n    both() {\n        return [this.intersectionPoint(0), this.intersectionPoint(1)];\n    }\n\n    // return any point that satisfies the given criterion (the point\n    // is invalid if no intersections satisfy the given criterion)\n    select(selectionFun, redraw) {\n        return this.intersectionPoint(selectionFun, redraw);\n    }\n\n    // perform the selection based on the given criterion (this method\n    // is called by the single intersection point objects)\n    selectPoint(selectionCriterion) {\n        if (typeof selectionCriterion == \"function\") {\n            const selected = this._intersections.filter(selectionCriterion);\n            if (selected.length > 0)\n                return selected[0];\n            console.log(selectionCriterion);\n            throw \"No selected points\";\n        }\n        \n        if (typeof selectionCriterion == \"number\")\n            return this._intersections[selectionCriterion];\n\n        throw \"Unknown criterion\";\n    }\n\n    isNear(x, y, worldToScreen) {\n        // FIXME: perform the check\n        return false;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// all intersections of a line and a circle\n// -----------------------------------------------------------------------------\nclass DGIntersectLC extends DGIntersections {\n    constructor(l, c) {\n        super();\n        this._l = l;\n        this._c = c;\n        // if the circle or the line changes, the intersection must be updated\n        c.addDependent(this);\n        l.addDependent(this);\n        // initialize the intersection coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersectLC\";\n    }\n\n    defaultDescription() {\n        return \"intersection of \" + this._l.label() + \" and \" + this._c.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._l._valid && this._c._valid;\n        this._intersections = DGCircle.intersectLC(this._l, this._c);\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// all intersections of two circles\n// -----------------------------------------------------------------------------\nclass DGIntersectCC extends DGIntersections {\n    constructor(c1, c2) {\n        super();\n        this._c1 = c1;\n        this._c2 = c2;\n        // if any of the circles changes, the intersection must be updated\n        c1.addDependent(this);\n        c2.addDependent(this);\n        // initialize the intersection coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersectCC\";\n    }\n    \n    defaultDescription() {\n        return \"intersection of \" + this._c1.label() + \" and \" + this._c2.label();\n    }\n\n    // recalculate the coordinates\n    recalcMe() {\n        this._valid = this._c1._valid && this._c2._valid;\n        this._intersections = DGCircle.intersectCC(this._c1, this._c2);\n    }\n}\n\n// -----------------------------------------------------------------------------\n// a single intersection point selected from the set of all intersection points\n// by some criteria\n// -----------------------------------------------------------------------------\nclass DGIntersectPoint extends DGPoint {\n    constructor(intersections, selectionCriterion, description) {\n        super();\n        this._intersections = intersections;\n        this._selectionCriterion = selectionCriterion;\n        this.description(description, false);\n        \n        // initialize the coordinates\n        this.recalcMe();\n    }\n\n    type() {\n        return \"intersection point\";\n    }\n\n    // although this is a single point, it is not free\n    isFreePoint() {\n        return false;\n    }\n    \n    // recalculate the coordinates\n    recalcMe() {\n        // if no point satisfies the selection criterion, then this point is invalid\n        this._valid = this._intersections._valid;\n        try {\n            this._coords = this._intersections.selectPoint(this._selectionCriterion);\n        } catch (err) {\n            console.log(err);\n            this._valid = false;\n        }\n    }\n}\n\n// -----------------------------------------------------------------------------\n// condition\n// -----------------------------------------------------------------------------\n\nclass DGIf extends DGObject {\n    constructor(condition, thenObject, elseObject, dependencies) {\n        super();\n        this._condition = condition;\n        this._thenObject = thenObject;\n        this._elseObject = elseObject;\n        this._dependencies = dependencies;\n        thenObject.addDependent(this);\n        elseObject.addDependent(this);\n        dependencies.forEach(o => o.addDependent(this));\n        this.recalcMe();\n    }\n\n    type() {\n        return \"if\";\n    }\n\n    isPoint() {\n        return this._object.isPoint();\n    }\n\n    isLine() {\n        return this._object.isLine();\n    }\n\n    isCircle() {\n        return this._object.isLine();\n    }\n    \n    color(c) {\n        // if c is undefined get the color\n        if (c === undefined)\n            return this._object.color();\n        \n        // otherwise set the color\n        this._thenObject.color(c);\n        this._elseObject.color(c);\n        return this;\n    }\n\n    width(w) {\n        // if w is undefined get the width\n        if (w === undefined)\n            return this._object.width();\n\n        // otherwise set the width\n        this._thenObject.width(w);\n        this._elseObject.width(w);\n        return this;\n    }\n    \n    label(l, show_label, redraw) {\n        // if l is undefined get the label\n        if (l === undefined)\n            return this._object.label();\n        \n        // otherwise set the label\n        this._thenObject.label(l, show_label, redraw);\n        this._elseObject.label(l, show_label, redraw);\n        return this;\n    }\n\n    showingLabel() {\n        return this._object.showingLabel();\n    }\n\n    hasLabel() {\n        return this._object.hasLabel();\n    }\n\n    defaultDescription() {\n        return this._object.defaultDescription();\n    }\n\n    description(d) {\n        // if d is undefined get the description\n        if (d === undefined)\n            return this._object.description();\n\n        // otherwise set the description\n        this._thenObject.description(d);\n        this._elseObject.description(d);\n        return this;\n    }\n\n    style(st, redraw) {\n        if (st === undefined)\n            return this._object.style();\n\n        this._thenObject.style(st, redraw);\n        this._elseObject.style(st, redraw);\n    }\n\n    is_inf() {\n        return this._object.is_inf();\n    }\n    \n    to_complex() {\n        return this._object.to_complex();\n    }\n    \n    cp1() {\n        return this._object.cp1();\n    }\n\n    x() {\n        return this._object.x();\n    }\n\n    y() {\n        return this._object.y();\n    }\n    \n    coords() {\n        return this._object.coords();\n    }\n\n    distance(other) {\n        return this._object.distance(other);\n    }\n\n    intersect(l) {\n        return this._object.intersect(l);\n    }\n\n    circline() {\n        return this._object.circline();\n    }\n\n    randomPoint() {\n        return this._object.randomPoint();\n    }\n\n    recalcMe() {\n        if (this._condition(...this._dependencies)) {\n            this._object = this._thenObject;\n        } else {\n            this._object = this._elseObject;\n        }\n        this._valid = this._object._valid;\n    }\n\n    drawMe(view) {\n        this._object.drawMe(view);\n    }\n\n    highlight(h, redraw) {\n        this._object.highlight(h, redraw);\n    }\n\n    isNear(x, y, worldToScreen) {\n        return this._object.isNear(x, y, worldToScreen);\n    }\n    \n    drawLabel(view) {\n        this._object.drawLabel(view);\n    }\n}\n\nclass DGPoincareLine extends DGCircline {\n    constructor(p1, p2) {\n        super();\n        this._p1 = p1;\n        this._p2 = p2;\n        // if any of the two points move, this line must be updated\n        p1.addDependent(this);\n        p2.addDependent(this);\n        // initialize the internal circline representation (Hermitean matrix)\n        this.recalcMe();\n    }\n\n    type() {\n        return \"poincare line\";\n    }\n\n    defaultDescription() {\n        return \"Poincare line \" + this._p1.label() + this._p2.label();\n    }\n\n    recalcMe() {\n        const u = this._p1.cp1().to_complex();\n        const v = this._p2.cp1().to_complex();\n        const A = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult((u.mult(v.cnj())).sub(v.mult(u.cnj())));\n        const B = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Complex.i.mult(v.scale(u.norm2() + 1).sub(u.scale(v.norm2() + 1)));\n        this._circline = new _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline(A, B, B.cnj(), A);\n        this._valid = this._p1._valid && this._p2._valid;\n    }\n}\n\nclass DGPoincareCircle extends DGCircline {\n    constructor(c, p) {\n        super();\n        this._c = c;\n        this._p = p;\n        // if any of the two points move, this line must be updated\n        c.addDependent(this);\n        p.addDependent(this);\n        // initialize the circline\n        this.recalcMe();\n    }\n\n    type() {\n        return \"poincare circle\";\n    }\n\n    defaultDescription() {\n        return \"Poincare circle c(\" + this._c.label() + \", \" + this._p.label() + \")\";\n    }\n    \n    recalcMe() {\n        const u = this._c.cp1().to_complex();\n        const v = this._p.cp1().to_complex();\n        const r = Math.acosh(1 + (2 * u.sub(v).norm2()) / ((1 - u.norm2())* (1 - v.norm2())));\n        const ue = u.scale(1 / ((1 - u.norm2())*(Math.cosh(r) - 1)/2 + 1));\n        const re = ((1 - u.norm2()) * Math.sinh(r)) / ((1 - u.norm2()) * (Math.cosh(r) - 1) + 2);\n        this._circline = _complex_geom_js__WEBPACK_IMPORTED_MODULE_0__.Circline.mk_circle(ue, re);\n        this._valid = this._c._valid && this._p._valid;\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/objects.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/rc.js":
/*!******************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/rc.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"angle_bisector\": () => (/* binding */ angle_bisector),\n/* harmony export */   \"angle_divide\": () => (/* binding */ angle_divide),\n/* harmony export */   \"bisector\": () => (/* binding */ bisector),\n/* harmony export */   \"circle\": () => (/* binding */ circle),\n/* harmony export */   \"circle3_center\": () => (/* binding */ circle3_center),\n/* harmony export */   \"circle_over_segment\": () => (/* binding */ circle_over_segment),\n/* harmony export */   \"drop_perp\": () => (/* binding */ drop_perp),\n/* harmony export */   \"foot\": () => (/* binding */ foot),\n/* harmony export */   \"free\": () => (/* binding */ free),\n/* harmony export */   \"harmonic_conjugate\": () => (/* binding */ harmonic_conjugate),\n/* harmony export */   \"homothety_line\": () => (/* binding */ homothety_line),\n/* harmony export */   \"intersectCC_both\": () => (/* binding */ intersectCC_both),\n/* harmony export */   \"intersectCC_other\": () => (/* binding */ intersectCC_other),\n/* harmony export */   \"intersectLC_both\": () => (/* binding */ intersectLC_both),\n/* harmony export */   \"intersectLC_other\": () => (/* binding */ intersectLC_other),\n/* harmony export */   \"intersectLL\": () => (/* binding */ intersectLL),\n/* harmony export */   \"line\": () => (/* binding */ line),\n/* harmony export */   \"midpoint\": () => (/* binding */ midpoint),\n/* harmony export */   \"other_tangent\": () => (/* binding */ other_tangent),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel),\n/* harmony export */   \"point\": () => (/* binding */ point),\n/* harmony export */   \"reflectL\": () => (/* binding */ reflectL),\n/* harmony export */   \"reflectP\": () => (/* binding */ reflectP),\n/* harmony export */   \"segment\": () => (/* binding */ segment),\n/* harmony export */   \"tangents\": () => (/* binding */ tangents),\n/* harmony export */   \"touching_circle\": () => (/* binding */ touching_circle),\n/* harmony export */   \"towards\": () => (/* binding */ towards),\n/* harmony export */   \"triangle\": () => (/* binding */ triangle)\n/* harmony export */ });\n/* harmony import */ var _dg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dg.js */ \"./node_modules/ArgoDG/src/dg/dg.js\");\n/* harmony import */ var _complex_geom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../complex_geom.js */ \"./node_modules/ArgoDG/src/complex_geom.js\");\n\n\n\n// free point\nfunction point(x, y, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.point(x, y, redraw);\n}\n\nconst free = point;\n\n// line AB\n// det: A != B\nfunction line(A, B, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.line(A, B, redraw);\n}\n\n// segment AB\n// det: A != B\nfunction segment(A, B, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.segment(A, B, redraw);\n}\n\n// intersection of lines l1 and l2\n// non-deg: !parallel(l1, l2)\n// det: l1 != l2\nfunction intersectLL(l1, l2, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLL(l1, l2, redraw);\n}\n\n// both intersections of line l and circle c\n// non-deg: l intersects c\nfunction intersectLC_both(l, c, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_both(l, c, redraw);\n}\n\n// other intersection of line l and circle c (different from given point A)\n// non-deg: l intersects c (in two points)\nfunction intersectLC_other(l, c, A, redraw) {\n    const I = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select(l, c, p => !p.eq(A.cp1()), redraw)\n    return I;\n}\n\n// circle centered at C containing A\n// non-deg: C != A\nfunction circle(C, A, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.circle(C, A, redraw);\n}\n\n// both intersection of circles c1 and c2\n// non-deg: c1 intersects c2\n// det: c1 != c2\nfunction intersectCC_both(c1, c2, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_both(c1, c2, redraw);\n}\n\n// other intersection of circles c1 and c2 (different from the given point A)\n// non-deg: c1 intersects c2 (in two different points)\n// det: c1 != c2\nfunction intersectCC_other(c1, c2, A, redraw) {\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_select(c1, c2, p => !p.eq(A.cp1()), redraw);\n}\n\n// bisector of segment AB\n// nondeg: A != B\nfunction bisector(A, B, redraw) {\n    const c1 = circle(A, B, false).hide(false);\n    const c2 = circle(B, A, false).hide(false);\n    const [X1, X2] = intersectCC_both(c1, c2, false).map(p => p.hide(false));\n    const m = line(X1, X2, redraw);\n    m.description(\"Bisector of segment \" + A.label() + B.label(), false);\n    return m;\n}\n\n\n// midpoint of segment AB\nfunction midpoint(A, B, redraw) {\n    const m = bisector(A, B, false).hide(false);\n    const l = line(A, B, false).hide(false);\n    const M = intersectLL(m, l, false).hide(false);\n    const Mp = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((A, B) => A.eq(B), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(B, false).hide(false), M, [A, B], redraw);\n    Mp.description(\"Midpoint of segment \" + A.label() + B.label());\n    return Mp;\n}\n\n\n// circle over segment AB\n// non-deg: A != B\nfunction circle_over_segment(A, B, redraw) {\n    const l1 = line(A, B, false).hide(false);\n    const l2 = bisector(A, B, false).hide(false);\n    const M = intersectLL(l1, l2, false).hide(false);\n    return circle(M, A, redraw);\n}\n\n// line perpendicular to line l containing point A\nfunction drop_perp(l, A, redraw) {\n    const B = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(l, false).hide(false); // FIXME: diffferent from A\n    const c = circle(A, B, false).hide(false);\n    const [X1, X2] = intersectLC_both(l, c, false).map(p => p.hide(false));\n    const m = bisector(X1, X2, redraw);\n    m.description(\"Drop perpendicular from point \" + A.label() + \" onto line \" + l.label(), false);\n    return m;\n}\n\n// foot of the perpendicular projection of point A onto line l\nfunction foot(l, A, redraw)  {\n    const p = drop_perp(l, A, false).hide(false);\n    const X = intersectLL(p, l, false);\n    X.description(\"Project point \" + A.label() + \" onto line \" + l.label(), redraw);\n    return X;\n}\n\n// circle centered at point A that touches line l\n// non-deg: A not on l\nfunction touching_circle(A, l, redraw) {\n    const p = drop_perp(l, A, false).hide(false);\n    const M = intersectLL(p, l, false).hide(false);\n    const c = circle(A, M, false);\n    c.description(\"Circle centered in \" + A.label() + \" touching line \" + l.label(), redraw);\n    return c;\n}\n\n// both tangents from point A that touch circle c\n// non-deg: A outside c\nfunction tangents(A, c, redraw) {\n    const O = _dg_js__WEBPACK_IMPORTED_MODULE_0__.center(c, false).hide(false);\n    const c1 = circle_over_segment(O, A, false).hide(false);\n    const [X1, X2] = intersectCC_both(c, c1, false).map(p => p.hide(false));\n    return [line(A, X1, false), line(A, X2, false)].map(l => l.description(\n        \"Tangent from point \" + A.label() + \" to circle \" + c.label(), redraw\n    ));\n}\n\n// tangent from point A that touch circle c, that is different from the given line t\n// non-deg: A outside c\nfunction other_tangent(A, c, t, redraw) {\n    const [t1, t2] = tangents(A, c, false);\n    const t_ = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((x, y) => x.eq(y), t2, t1, [t, t1], false);\n    t_.description(\"Tangent from point \" + A.label() + \" to circle \" + c.label(), false);\n    return t_.show(redraw);\n}\n\n// homothety of a line\nfunction homothety_line() {\n    // TODO\n}\n\n// parallel line to line l that contains point A\nfunction parallel(l, A, redraw) {\n    const n = drop_perp(l, A, false).hide(false);\n    return drop_perp(n, A, redraw);\n}\n\n\n// point Z such that XY : XZ = p : q\nfunction towards_aux(X, Y, p, q, redraw) {\n    const pp = Math.abs(p), qq = Math.abs(q);\n    const M = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint(false).hide(false);\n    // change M whenever X and Y change\n    X.addDependent(M); Y.addDependent(M);\n    const l = line(X, M, false).hide(false);\n    const points = [X, M];\n    for (let i = 0; i < Math.max(pp, qq); i++) {\n        const O = points[points.length - 1];\n        const A = points[points.length - 2];\n        const c = circle(O, A, false).hide(false);\n        const MM = intersectLC_other(l, c, A, false).hide(false);\n        points.push(MM);\n    }\n\n    const p1 = line(Y, points[pp], false).hide(false);\n    const p2 = parallel(p1, points[qq], false).hide(false);\n    const xy = line(X, Y, false).hide(false);\n    let Z =  intersectLL(xy, p2, false).hide(false);\n\n    if (p*q < 0)\n        Z = reflectP(X, Z, false).hide(false);\n\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, Y) => X.eq(Y), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(X, false).hide(false), Z, [X, Y], redraw);\n}\n\n// point B such that vector AB equals vector XY\nfunction translate_vec(X, Y, A, redraw) {\n    const xy = line(X, Y, false).hide(false);\n    const xa = line(X, A, false).hide(false);\n    const p1 = parallel(xy, A, false).hide(false);\n    const p2 = parallel(xa, Y, false).hide(false);\n    const B = intersectLL(p1, p2, false).hide(false);\n    return _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, Y) => X.eq(Y),\n                 _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(A, false).hide(false),\n                 _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((X, A) => X.eq(A),\n                       _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(Y, false).hide(false),\n                       B,\n                       [X, A]).hide(false),\n                 [X, Y], redraw);\n}\n\n// point W such that XY : ZW = p : q\nfunction towards(X, Y, Z, p, q, redraw) {\n    const YY = towards_aux(X, Y, p, q, false).hide(false);\n    const w = translate_vec(X, YY, Z, false).show(false);\n    w.description(\"Point X such that \" + X.label() + Y.label() + \":\" + Z.label() + \"X\" + \" = \" + p + \":\" + q, redraw);\n    return w;\n}\n\n\n// angle divide\nfunction angle_divide() {\n    // TODO\n}\n\n// a line that bisect the angle BAC\nfunction angle_bisector(B, A, C, redraw) {\n    const k = circle(A, B, false).hide(false);\n    const c = line(A, B, false).hide(false);\n    const b = line(A, C, false).hide(false);\n    const X = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectLC_select(b, k, p => _complex_geom_js__WEBPACK_IMPORTED_MODULE_1__.Circline.same_side(p, C.cp1(), A.cp1()), false).hide(false);\n    const k1 = circle(B, X, false).hide(false);\n    const k2 = circle(X, B, false).hide(false);\n    const Y = _dg_js__WEBPACK_IMPORTED_MODULE_0__.intersectCC_any(k1, k2, false).hide(false);\n    const l = line(A, Y, false);\n    l.description(\"Angle \" + B.label() + A.label() + C.label() + \" bisector\", redraw);\n    return l;\n}\n\n// reflection of point B around point O\nfunction reflectP(O, B, redraw) {\n    const l = line(O, B, false).hide(false);\n    const c = circle(O, B, false).hide(false);\n    const BB = intersectLC_other(l, c, B, false).hide(false);\n    const r = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((O, B) => O.eq(B), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(B, false).hide(false), BB, [O, B], false);\n    r.description(\"Reflect point \" + B.label() + \" over point \" + O.label(), redraw);\n    return r;\n}\n\n// reflection of point A around line l\nfunction reflectL(l, A, redraw) {\n    const p = drop_perp(l, A, false).hide(false);\n    const M = intersectLL(p, l, false).hide(false);\n    const c = circle(M, A, false).hide(false);\n    const AA = intersectLC_other(p, c, A, false).hide(false);\n    const r = _dg_js__WEBPACK_IMPORTED_MODULE_0__.If((A, M) => A.eq(M), _dg_js__WEBPACK_IMPORTED_MODULE_0__.clone(A, false).hide(false), AA, [A, M], false);\n    r.description(\"Reflect point \" + A.label() + \" over line \" + l.label(), redraw);\n    return r;\n}\n\n// circumcenter of triangle ABC\nfunction circle3_center(A, B, C, redraw) {\n    const ma = bisector(B, C, false).hide(false);\n    const mb = bisector(A, C, false).hide(false);\n    const O = intersectLL(ma, mb, redraw);\n    return O;\n}\n\n// point D such that H(A, B, C, D)=-1\n// non-deg: collinear A, B, C and C != A and C != B and C is not midpoint of AB\nfunction harmonic_conjugate(A, B, C, redraw) {\n    const R = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPoint(false).hide(false);\n    A.addDependent(R); B.addDependent(R); C.addDependent(R);\n    const ra = line(R, A, false).hide(false);\n    const rb = line(R, B, false).hide(false);\n    const Q = _dg_js__WEBPACK_IMPORTED_MODULE_0__.randomPointOnLine(la, false).hide(false);\n    const qc = line(Q, C, false).hide(false);\n    const P = intersectLL(rb, qc, false).hide(false);\n    const ap = line(A, P, false).hide(false);\n    const bq = line(B, Q, false).hide(false);\n    const S = intersectLL(ap, bq, false).hide(false);\n    const ab = line(A, B, false).hide(false);\n    const rs = line(R, S, false).hide(false);\n    return intersectLL(ab, rs, redraw);\n}\n\n// all significant points of the triangle\nfunction triangle(A, B, C) {\n    const elements = [A, B, C];\n    // sides\n    const a = line(B, C).label(\"a\").color(\"black\").width(2); elements.push(a);\n    const b = line(A, C).label(\"b\").color(\"black\").width(2); elements.push(b);\n    const c = line(A, B).label(\"c\").color(\"black\").width(2); elements.push(c);\n\n    // side bisectors\n    const ba = bisector(B, C).color(\"blue\").label(\"b_{a}\"); elements.push(ba);\n    const bb = bisector(A, C).color(\"blue\").label(\"b_{b}\"); elements.push(bb);\n    const bc = bisector(A, B).color(\"blue\").label(\"b_{c}\"); elements.push(bc);\n\n    // circumcenter\n    const O = intersectLL(ba, bb).color(\"blue\").label(\"O\"); elements.push(O);\n    // circumcircle\n    const o = circle(O, A).color(\"blue\"); elements.push(o);\n\n    // side midpoints\n    const Ma = midpoint(B, C).color(\"green\").label(\"M_{a}\"); elements.push(Ma);\n    const Mb = midpoint(A, C).color(\"green\").label(\"M_{b}\"); elements.push(Mb);\n    const Mc = midpoint(A, B).color(\"green\").label(\"M_{c}\"); elements.push(Mc);\n\n    // angle bisectors\n    const ta = angle_bisector(B, A, C).color(\"orange\").label(\"t_{a}\"); elements.push(ta);\n    const tb = angle_bisector(A, B, C).color(\"orange\").label(\"t_{b}\"); elements.push(tb);\n    const tc = angle_bisector(B, C, A).color(\"orange\").label(\"t_{c}\"); elements.push(tc);\n    // incenter\n    const I = intersectLL(ta, tb).color(\"orange\").label(\"I\"); elements.push(I);\n\n    // angle bisector feet\n    const Ta = intersectLL(ta, a).color(\"orange\").label(\"T_{a}\"); elements.push(Ta);\n    const Tb = intersectLL(tb, b).color(\"orange\").label(\"T_{b}\"); elements.push(Tb);\n    const Tc = intersectLL(tc, c).color(\"orange\").label(\"T_{c}\"); elements.push(Tc);\n\n    // incenter perpendicular projections onto triangle sides\n    const tpa = drop_perp(a, I).color(\"Chocolate\").label(\"t'_{a}\"); elements.push(tpa);\n    const tpb = drop_perp(b, I).color(\"Chocolate\").label(\"t'_{b}\"); elements.push(tpb);\n    const tpc = drop_perp(c, I).color(\"Chocolate\").label(\"t'_{c}\"); elements.push(tpc);\n\n    // incenter projection feet\n    const Tpa = intersectLL(tpa, a).color(\"Chocolate\").label(\"T'_{a}\"); elements.push(Tpa);\n    const Tpb = intersectLL(tpb, b).color(\"Chocolate\").label(\"T'_{b}\"); elements.push(Tpb);\n    const Tpc = intersectLL(tpc, c).color(\"Chocolate\").label(\"T'_{c}\"); elements.push(Tpc);\n\n    // incircle\n    const i = circle(I, Tpa).color(\"orange\").label(\"i\"); elements.push(i);\n\n    // altitudes\n    const ha = drop_perp(a, A).color(\"red\").label(\"h_{a}\"); elements.push(ha);\n    const hb = drop_perp(b, B).color(\"red\").label(\"h_{b}\"); elements.push(hb);\n    const hc = drop_perp(c, C).color(\"red\").label(\"h_{c}\"); elements.push(hc);\n\n    // orthocenter\n    const H = intersectLL(ha, hb).color(\"red\").label(\"H\"); elements.push(H);\n\n    // altitude feet\n    const Ha = intersectLL(ha, a).color(\"red\").label(\"H_{a}\"); elements.push(Ha);\n    const Hb = intersectLL(hb, b).color(\"red\").label(\"H_{b}\"); elements.push(Hb);\n    const Hc = intersectLL(hc, c).color(\"red\").label(\"H_{c}\"); elements.push(Hc);\n\n    // circles over triangle sides\n    const ca = circle(Ma, B).color(\"DimGray\"); elements.push(ca);\n    const cb = circle(Mb, A).color(\"DimGray\"); elements.push(cb);\n    const cc = circle(Mc, A).color(\"DimGray\"); elements.push(cc);\n\n    // medians\n    const ma = line(A, Ma).color(\"green\").label(\"m_{a}\"); elements.push(ma);\n    const mb = line(B, Mb).color(\"green\").label(\"m_{b}\"); elements.push(mb);\n    const mc = line(C, Mc).color(\"green\").label(\"m_{c}\"); elements.push(mc);\n\n    // centroid\n    const G = intersectLL(ma, mb).color(\"green\").label(\"G\"); elements.push(G);\n\n    // midlines\n    const MaMb = line(Ma, Mb).color(\"DarkTurquoise\"); elements.push(MaMb);\n    const MaMc = line(Ma, Mc).color(\"DarkTurquoise\"); elements.push(MaMc);\n    const MbMc = line(Mb, Mc).color(\"DarkTurquoise\"); elements.push(MbMc);\n\n    // Euler line\n    const e = line(O, H).color(\"purple\").label(\"e\"); elements.push(e);\n    // Euler points\n    const Ea = midpoint(A, H).color(\"purple\").label(\"E_{a}\"); elements.push(Ea);\n    const Eb = midpoint(B, H).color(\"purple\").label(\"E_{b}\"); elements.push(Eb);\n    const Ec = midpoint(C, H).color(\"purple\").label(\"E_{c}\"); elements.push(Ec);\n\n    // Euler (nine-point) circle center\n    const N = circle3_center(Ma, Mb, Mc).color(\"purple\").label(\"N\"); elements.push(N);\n    // Euler (nine-point) circle\n    const n = circle(N, Ma).color(\"purple\").label(\"Ec\"); elements.push(n);\n\n    // Euler circles\n    const cEaA = circle(Ea, A).color(\"magenta\"); elements.push(cEaA);\n    const cEbB = circle(Eb, B).color(\"magenta\"); elements.push(cEbB);\n    const cEcC = circle(Ec, C).color(\"magenta\"); elements.push(cEcC);\n\n    // angle bisector and side bisector intersections\n    const Na = intersectLL(ba, ta).label(\"N_{a}\").color(\"DeepPink\"); elements.push(Na);\n    const Nb = intersectLL(bb, tb).label(\"N_{b}\").color(\"DeepPink\"); elements.push(Nb);\n    const Nc = intersectLL(bc, tc).label(\"N_{c}\").color(\"DeepPink\"); elements.push(Nc);\n\n    const cNaI = circle(Na, I).color(\"DeepPink\"); elements.push(cNaI);\n    const cNbI = circle(Nb, I).color(\"DeepPink\"); elements.push(cNbI);\n    const cNcI = circle(Nc, I).color(\"DeepPink\"); elements.push(cNcI);\n\n    // angle bisector feet projections onto other triangle sides\n    const Ta_b = foot(b, Ta).color(\"Olive\").label(\"T_{ab}\"); elements.push(Ta_b);\n    const Ta_c = foot(c, Ta).color(\"Olive\").label(\"T_{ac}\"); elements.push(Ta_c);\n    const cTa = circle(Ta, Ta_b).color(\"Olive\").label(\"c_{Ta}\"); elements.push(cTa);\n\n    const Tb_a = foot(a, Tb).color(\"Olive\").label(\"T_{ba}\"); elements.push(Tb_a);\n    const Tb_c = foot(c, Tb).color(\"Olive\").label(\"T_{bc}\"); elements.push(Tb_c);\n    const cTb = circle(Tb, Tb_a).color(\"Olive\").label(\"c_{Tb}\"); elements.push(cTb);\n\n    const Tc_a = foot(a, Tc).color(\"Olive\").label(\"T_{ca}\"); elements.push(Tc_a);\n    const Tc_b = foot(b, Tc).color(\"Olive\").label(\"T_{cb}\"); elements.push(Tc_b);\n    const cTc = circle(Tc, Tc_a).color(\"Olive\").label(\"c_{Tc}\"); elements.push(cTc);\n\n\n    // out angle bisectors\n    const sa = drop_perp(ta, A).color(\"tomato\").label(\"s_{a}\"); elements.push(sa);\n    const sb = drop_perp(tb, B).color(\"tomato\").label(\"s_{b}\"); elements.push(sb);\n    const sc = drop_perp(tc, C).color(\"tomato\").label(\"s_{c}\"); elements.push(sc);\n\n    // outcircle centers\n    const Ia = intersectLL(sb, sc).color(\"tomato\").label(\"I_{a}\"); elements.push(Ia);\n    const Ib = intersectLL(sa, sc).color(\"tomato\").label(\"I_{b}\"); elements.push(Ib);\n    const Ic = intersectLL(sa, sb).color(\"tomato\").label(\"I_{c}\"); elements.push(Ic);\n\n    // outcenters perpendicular projections onto triangle sides\n    const Spa = foot(a, Ia).color(\"tomato\").label(\"S'_{a}\"); elements.push(Spa);\n    const Spb = foot(b, Ib).color(\"tomato\").label(\"S'_{b}\"); elements.push(Spb);\n    const Spc = foot(c, Ic).color(\"tomato\").label(\"S'_{b}\"); elements.push(Spc);\n\n    // outcircles\n    const ia = circle(Ia, Spa).color(\"tomato\").label(\"i_{a}\"); elements.push(ia);\n    const ib = circle(Ib, Spb).color(\"tomato\").label(\"i_{b}\"); elements.push(ib);\n    const ic = circle(Ic, Spc).color(\"tomato\").label(\"i_{c}\"); elements.push(ic);\n\n    // out angle bisector feet\n    const Sa = intersectLL(sa, a).color(\"tomato\").label(\"S_{a}\"); elements.push(Sa);\n    const Sb = intersectLL(sb, b).color(\"tomato\").label(\"S_{b}\"); elements.push(Sb);\n    const Sc = intersectLL(sc, c).color(\"tomato\").label(\"S_{c}\"); elements.push(Sc);\n\n    // circles over segments formed by inner and outer angle bisector feet\n    const cTaSa = circle_over_segment(Ta, Sa).color(\"IndianRed\"); elements.push(cTaSa);\n    const cTbSb = circle_over_segment(Tb, Sb).color(\"IndianRed\"); elements.push(cTbSb);\n    const cTcSc = circle_over_segment(Tc, Sc).color(\"IndianRed\"); elements.push(cTcSc);\n\n    // some parallel lines :)\n    const IMa = line(I, Ma).color(\"DarkGray\").width(1.5); elements.push(IMa);\n    const ASpa = line(A, Spa).color(\"DarkGray\").width(1.5); elements.push(ASpa);\n\n    const IMb = line(I, Mb).color(\"DarkGray\").width(1.5); elements.push(IMb);\n    const BSpb = line(B, Spb).color(\"DarkGray\").width(1.5); elements.push(BSpb);\n\n    const IMc = line(I, Mc).color(\"DarkGray\").width(1.5); elements.push(IMc);\n    const CSpc = line(C, Spc).color(\"DarkGray\").width(1.5); elements.push(CSpc);\n\n    elements.map(obj => obj.hide());\n    return elements;\n}\n\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/rc.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/tool.js":
/*!********************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/tool.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConstructionToolbar\": () => (/* binding */ ConstructionToolbar),\n/* harmony export */   \"ToolDragFree\": () => (/* binding */ ToolDragFree)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./node_modules/ArgoDG/src/dg/view.js\");\n/* harmony import */ var _rc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rc.js */ \"./node_modules/ArgoDG/src/dg/rc.js\");\n\n\n\n// -----------------------------------------------------------------------------\n// highlighting specific objects as the mouse moves over them\n// -----------------------------------------------------------------------------\nclass Highlighter {\n    // this should be overridden\n    shouldHighlight(obj) {\n        return false;\n    }\n}\n\nclass HighlighterFreePoints extends Highlighter {\n    shouldHighlight(obj) {\n        return obj.isFreePoint();\n    }\n}\nconst highlighterFreePoints = new HighlighterFreePoints();\n\nclass HighlighterPoints extends Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isPoint();\n    }\n}\nconst highlighterPoints = new HighlighterPoints();\n\nclass HighlighterLines extends Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isLine();\n    }\n}\nconst highlighterLines = new HighlighterLines();\n\nclass HighlighterCircles extends Highlighter  {\n    shouldHighlight(obj) {\n        return obj.isCircle();\n    }\n}\nconst highlighterCircles = new HighlighterCircles();\n\n\n// -----------------------------------------------------------------------------\n// handling of mouse and keyboard events on a view\n// -----------------------------------------------------------------------------\nclass Tool {\n    constructor(view) {\n        this._view = view;\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n    }\n\n    mousedown(x, y, worldToScreen, screenToWorld) {\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n    }\n    \n    keydown(e, worldToScreen, screenToWorld) {\n    }\n\n\n    highlightAt(x, y, worldToScreen) {\n        if (!this._highlighter)\n            return;\n        this._construction.highlightAt(x, y, worldToScreen, this._highlighter);\n    }\n\n    getObject() {\n        return undefined;\n    }\n}\n\n\nclass ToolDragFree extends Tool {\n    constructor(view, construction) {\n        super(view);\n\n        this._highlighter = highlighterFreePoints;\n        \n        // mouse button is not yet pressed\n        this._mousedown = false;\n        // point dragged by the mouse\n        this._dragPoint = undefined;\n        // point moved by the keyboard\n        this._keyboardTarget = undefined;\n        // construction whose points can be dragged\n        // (if not specified all existing points free points can be dragged)\n        this._construction = construction;\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n        if (this._mousedown && this._dragPoint !== undefined) {\n            const [xw, yw] = screenToWorld(x, y);\n            if (!this._dragPoint.moveTo(xw, yw)) {\n                const N = 10;\n                for (let d = 1; d <= N; d++) {\n                    let ring = [];\n                    for (let x = -d; x <= d; x++)\n                        ring.push([x, -d]);\n                    for (let y = -d+1; y <= d; y++)\n                        ring.push([d, y]);\n                    for (let x = d-1; x >= -d; x--)\n                        ring.push([x, d]);\n                    for (let y = d-1; y >= -d+1; y--)\n                        ring.push([-d, y]);\n\n                    for (let i = 0; i < ring.length; i++) {\n                        const [dx, dy] = ring[i];\n                        const [xw, yw] = screenToWorld(x+dx, y+dy);\n                        if (this._dragPoint.moveTo(xw, yw))\n                            return;\n                    }\n                }\n            }\n        }\n        this.highlightAt(x, y, worldToScreen);\n    }\n\n    mousedown(x, y, worldToScreen, screenToWorld) {\n        this._mousedown = true;\n        this._dragPoint = this._construction.findFreePointAt(x, y, worldToScreen);\n        this._keyboardTarget = this._dragPoint;\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n        this._mousedown = false;\n        this._dragPoint = undefined;\n    }\n\n    keydown(e, worldToScreen, screenToWorld) {\n        if (!this._keyboardTarget)\n            return;\n        const p = this._keyboardTarget;\n        let [x, y] = [p.x(), p.y()];\n        let [xt, yt] = worldToScreen(x, y);\n        const eps = 2;\n        if (e.key == \"ArrowRight\")\n            xt += 1;\n        else if (e.key == \"ArrowLeft\")\n            xt -= 1;\n        if (e.key == \"ArrowUp\")\n            yt -= 1;\n        else if (e.key == \"ArrowDown\")\n            yt += 1;\n\n        [x, y] = screenToWorld(xt, yt)\n        p.moveTo(x, y);\n    }\n}\n\n\nclass Tool_ConstructObject extends Tool {\n    constructor(view, types, construction, callback) {\n        super(view);\n        this._object = undefined;\n        this._types = types;\n        this._selected = [];\n        this._construction = construction;\n        this._callback = callback;\n\n        this._view.message(\"Select a \" + this.typeName(this._types[0]));\n        this._highlighter = this.highlighter(this._types[0]);\n    }\n\n    typeName(t) {\n        if (t == 'p') return \"point\";\n        if (t == 'l') return \"line\";\n        if (t == 'c') return \"circle\";\n    }\n\n    highlighter(t) {\n        if (t == 'p') return highlighterPoints;\n        if (t == 'l') return highlighterLines;\n        if (t == 'c') return highlighterCircles;\n    }\n\n    mouseup(x, y, worldToScreen, screenToWorld) {\n        let obj;\n        const k = this._selected.length;\n        if (this._types[k] == \"p\")\n            obj = this._construction.findPointAt(x, y, worldToScreen);\n        else if (this._types[k] == \"l\")\n            obj = this._construction.findLineAt(x, y, worldToScreen);\n        else if (this._types[k] == \"c\")\n            obj = this._construction.findCircleAt(x, y, worldToScreen);\n        if (!obj)\n            return;\n\n        this._selected.push(obj);\n        \n        if (this._selected.length == this._types.length) {\n            this._object = this.construct(...this._selected);\n            if (this._callback)\n                this._callback(this._object);\n            this._selected = [];\n        }\n\n        let msg = \"\";\n        this._selected.forEach((obj, i) => {msg += \"Selected \" + this.typeName(this._types[i]) + \" \" + obj.label() + \". \"});\n        msg += \"Select a \" + this.typeName(this._types[this._selected.length]);\n        this._view.message(msg);\n        this._highlighter = this.highlighter(this._types[this._selected.length]);\n    }\n\n    mousemove(x, y, worldToScreen, screenToWorld) {\n        this.highlightAt(x, y, worldToScreen, screenToWorld);\n    }\n    \n    getObject() {\n        return this._object;\n    }\n}\n\n\nclass ToolLine extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2);\n    }\n}\n\nclass ToolMidpoint extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.midpoint(p1, p2);\n    }\n}\n\nclass ToolBisector extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.bisector(p1, p2);\n    }\n}\n\nclass ToolCircle extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pp\", construction, callback);\n    }\n    \n    construct(p1, p2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.circle(p1, p2);\n    }\n}\n\nclass ToolDropPerp extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pl\", construction, callback);\n    }\n\n    construct(p, l) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.drop_perp(l, p);\n    }\n}\n\nclass ToolParallel extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"pl\", construction, callback);\n    }\n\n    construct(p, l) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.parallel(l, p);\n    }\n}\n\nclass ToolIntersectLL extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"ll\", construction, callback);\n    }\n\n    construct(l1, l2) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLL(l1, l2);\n    }\n}\n\nclass ToolIntersectLC extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"lcp\", construction, callback);\n    }\n\n    construct(l, c, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectLC_other(l, c, p);\n    }\n}\n\nclass ToolIntersectCC extends Tool_ConstructObject {\n    constructor(view, construction, callback) {\n        super(view, \"ccp\", construction, callback);\n    }\n\n    construct(c1, c2, p) {\n        return _rc_js__WEBPACK_IMPORTED_MODULE_1__.intersectCC_other(c1, c2, p);\n    }\n}\n\n\nclass ConstructionToolbar {\n    constructor(construction, view, element, callback) {\n        this._construction = construction;\n        this._view = view;\n        this._tool_callback = callback;\n        \n        const divTools = document.createElement(\"div\");\n        element.prepend(divTools);\n        \n        const self = this;\n        \n        const btnDrag = document.createElement(\"button\");\n        btnDrag.innerHTML = \"drag\";\n        btnDrag.addEventListener(\"click\", function() {\n            self._view.message(\"\");\n            self.setTool(new ToolDragFree(self._view, self._construction));\n\n        });\n        divTools.append(btnDrag);\n\n        const btnLine = document.createElement(\"button\");\n        btnLine.innerHTML = \"line\";\n        btnLine.addEventListener(\"click\", function() {\n            self.setTool(new ToolLine(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnLine);\n\n        const btnCircle = document.createElement(\"button\");\n        btnCircle.innerHTML = \"circle\";\n        btnCircle.addEventListener(\"click\", function() {\n            self.setTool(new ToolCircle(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnCircle);\n        \n        const btnMidpoint = document.createElement(\"button\");\n        btnMidpoint.innerHTML = \"midpoint\";\n        btnMidpoint.addEventListener(\"click\", function() {\n            self.setTool(new ToolMidpoint(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnMidpoint);\n\n        const btnBisector = document.createElement(\"button\");\n        btnBisector.innerHTML = \"bisector\";\n        btnBisector.addEventListener(\"click\", function() {\n            self.setTool(new ToolBisector(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnBisector);\n        \n        const btnDropPerp = document.createElement(\"button\");\n        btnDropPerp.innerHTML = \"perp\";\n        btnDropPerp.addEventListener(\"click\", function() {\n            self.setTool(new ToolDropPerp(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnDropPerp);\n\n        const btnParallel = document.createElement(\"button\");\n        btnParallel.innerHTML = \"parallel\";\n        btnParallel.addEventListener(\"click\", function() {\n            self.setTool(new ToolParallel(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnParallel);\n\n        divTools.append(document.createElement(\"br\"));\n        \n        const btnIntersectLL = document.createElement(\"button\");\n        btnIntersectLL.innerHTML = \"intersectLL\";\n        btnIntersectLL.addEventListener(\"click\", function() {\n            self.setTool(new ToolIntersectLL(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnIntersectLL);\n\n        const btnIntersectLC = document.createElement(\"button\");\n        btnIntersectLC.innerHTML = \"intersectLC\";\n        btnIntersectLC.addEventListener(\"click\", function() {\n            self.setTool(new ToolIntersectLC(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnIntersectLC);\n\n        const btnIntersectCC = document.createElement(\"button\");\n        btnIntersectCC.innerHTML = \"intersectCC\";\n        btnIntersectCC.addEventListener(\"click\", function() {\n            self.setTool(new ToolIntersectCC(self._view, self._construction, self._tool_callback));\n        });\n        divTools.append(btnIntersectCC);\n        \n        [...divTools.getElementsByTagName(\"button\")].forEach(button => { button.style.fontSize = \"12px\"; });\n    }\n\n    setTool(tool) {\n        this._view.setTool(tool);\n    }    \n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/tool.js?");

/***/ }),

/***/ "./node_modules/ArgoDG/src/dg/view.js":
/*!********************************************!*\
  !*** ./node_modules/ArgoDG/src/dg/view.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"View\": () => (/* binding */ View)\n/* harmony export */ });\n/* harmony import */ var _latex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./latex.js */ \"./node_modules/ArgoDG/src/dg/latex.js\");\n/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas.js */ \"./node_modules/ArgoDG/src/dg/canvas.js\");\n/* harmony import */ var _tool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool.js */ \"./node_modules/ArgoDG/src/dg/tool.js\");\n\n\n\n\n// -----------------------------------------------------------------------------\n// drawing view enables drawing objects given in the world coordinate system\n// -----------------------------------------------------------------------------\nclass View {\n    constructor(element, options, xmin, xmax, ymin, ymax) {\n        if (arguments.length == 2) {\n            [xmin, xmax] = [-5, 5];\n            [ymin, ymax] = [-5, 5];\n        }\n        this._canvas = new _canvas_js__WEBPACK_IMPORTED_MODULE_1__.Canvas(element, options);\n        this.setVisibleRange(xmin, xmax, ymin, ymax);\n        \n        // constructions that are shown by this view\n        this._constructions = [];\n\n        // tool that react to the mouse and keyboard events\n        this._tool = undefined;\n\n        // panning tool\n        this._startPan = undefined;\n        \n        this.addEventListener('mousemove', this.mousemove.bind(this), false);\n        this.addEventListener('mousedown', this.mousedown.bind(this), false);\n        this.addEventListener('mouseup', this.mouseup.bind(this), false);\n        document.body.addEventListener('keydown', this.keydown.bind(this), false);\n    }\n\n    setConstruction(construction) {\n        this._constructions = [construction];\n        construction.drawView(this);\n    }\n\n    addConstruction(construction) {\n        this._constructions.push(construction);\n        construction.drawView(this);\n    }\n\n    setVisibleRange(xmin, xmax, ymin, ymax) {\n        this._xmin = xmin;\n        this._xmax = xmax;\n        this._ymin = ymin;\n        this._ymax = ymax;\n        const ratio = window.devicePixelRatio;\n        this._scalex = (this._canvas.width()) / (xmax - xmin);\n        this._scaley = (this._canvas.height()) / (ymax - ymin);\n        this._x0 = -xmin * this._scalex;\n        this._y0 = ymax * this._scaley;\n    }\n\n    drawObject(obj) {\n        obj.draw(this);\n    }\n\n    drawObjects(objects) {\n        // draw points above other objects\n        objects.filter(o => !o.isPoint()).forEach(obj => {this.drawObject(obj);});\n        objects.filter(o => o.isPoint()).forEach(obj => {this.drawObject(obj);});\n    }\n\n    redraw() {\n        this.clear();\n        this._constructions.forEach(construction => {\n            construction.drawView(this);\n        });\n    }\n\n    zoom(factor) {\n        const w = this._xmax - this._xmin;\n        const h = this._ymax - this._ymin;\n        const cx = (this._xmin + this._xmax) / 2;\n        const cy = (this._ymin + this._ymax) / 2;\n        this.setVisibleRange(cx - w/(2 * factor), cx + w/(2 * factor),\n                             cy - h/(2 * factor), cy + h/(2 * factor));\n        this.redraw();\n    }\n\n    pan(startPan, endPan) {\n        const dX = endPan.X - startPan.X;\n        const dY = endPan.Y - startPan.Y;\n        const w = this._canvas.width();\n        const h = this._canvas.height();\n        const dx = -dX / w * (this._xmax - this._xmin);\n        const dy = dY / w * (this._xmax - this._xmin);\n        this.setVisibleRange(this._xmin + dx, this._xmax + dx,\n                             this._ymin + dy, this._ymax + dy);\n        this.redraw();\n    }\n\n    canvas() {\n        return this._canvas;\n    }\n\n    addEventListener(event, fun) {\n        this._canvas.addEventListener(event, fun);\n    }\n\n    clear() {\n        this._canvas.clear();\n    }\n\n    worldToScreen(x, y) {\n        return [this._x0 + x * this._scalex, this._y0 - y * this._scaley];\n    }\n\n    screenToWorld(x, y) {\n        return [(x - this._x0) / this._scalex, (this._y0 - y) / this._scaley];\n    }\n\n    point(x, y, options) {\n        options = options || {}\n        const size = options.size || 1;\n        const [xt, yt] = this.worldToScreen(x, y);\n        this._canvas.circle(xt, yt, 4 * size, options.color, undefined, undefined, true)\n    }\n\n    text(x, y, txt) {\n        txt = (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.removeLaTeX)(txt);\n        const [xt, yt] = this.worldToScreen(x, y);\n        const displace = 8;\n        this._canvas.text(xt + displace, yt + displace, txt);\n    }\n    \n    segment(x1, y1, x2, y2, options) {\n        options = options || {}\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.segment(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n\n    line(x1, y1, x2, y2, options) {\n        options = options || {}\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.line(x1t, y1t, x2t, y2t, options.color, options.width, options.dash);\n    }\n\n    circle(x, y, r, options) {\n        options = options || {};\n        const [xt, yt] = this.worldToScreen(x, y);\n        const rt = r * this._scalex; // FIXME: different scales\n        this._canvas.circle(xt, yt, rt, options.color, options.width, options.dash);\n    }\n\n    line_label(x1, y1, x2, y2, color, label) {\n        label = (0,_latex_js__WEBPACK_IMPORTED_MODULE_0__.removeLaTeX)(label);\n        const [x1t, y1t] = this.worldToScreen(x1, y1);\n        const [x2t, y2t] = this.worldToScreen(x2, y2);\n        this._canvas.line_label(x1t, y1t, x2t, y2t, color, label);\n    }\n\n    message(msg) {\n        this._canvas.message(msg);\n    }\n\n    addMessage(msg) {\n        this._canvas.addMessage(msg);\n    }\n\n    setTool(tool) {\n        this._tool = tool;\n    }    \n\n    getMousePosition(e) {\n        return {X: e.offsetX, Y: e.offsetY};\n    }\n    \n    mousemove(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (this._startPan) {\n            this.pan(this._startPan, p);\n            this._startPan = p;\n        }\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mousemove(p.X, p.Y,\n                                 this.worldToScreen.bind(this),\n                                 this.screenToWorld.bind(this));\n    }\n\n    findObjectsAt(x, y) {\n        let objects = [];\n        this._constructions.forEach(construction => {\n            const c_objects = construction.findObjectsAt(p.X, p.Y,\n                                                         this.worldToScreen.bind(this));\n            objects.push(...c_objects);\n        });\n        return objects;\n    }\n\n    mousedown(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (e.ctrlKey)\n            this._startPan = p;\n\n        // show description\n        if (e.shiftKey) {\n            const p = this.getMousePosition(e);\n            const objects = this.findObjectsAt(p.X, p.Y);\n            \n            this.message(\"\");\n            objects.forEach(obj => {\n                this.addMessage(obj.describe());\n            });\n        }\n        \n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mousedown(p.X, p.Y,\n                                 this.worldToScreen.bind(this),\n                                 this.screenToWorld.bind(this));\n    }\n\n    mouseup(e) {\n        // mouse position\n        const p = this.getMousePosition(e);\n        \n        // panning\n        if (this._startPan) {\n            this.pan(this._startPan, p);\n            this._startPan = undefined;\n        }\n\n        // reset message\n        if (e.shiftKey)\n            this.message(\"\");\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.mouseup(p.X, p.Y,\n                               this.worldToScreen.bind(this),\n                               this.screenToWorld.bind(this));\n    }\n\n    keydown(e) {\n        // zooming\n        if (e.ctrlKey && e.code == 'NumpadAdd') { // numpad +\n            e.preventDefault();\n            this.zoom(1.5);\n        } else if (e.ctrlKey && e.code == 'NumpadSubtract') { // numpad -\n            e.preventDefault();\n            this.zoom(1 / 1.5);\n        }\n\n        // specific actions by the current tool \n        if (this._tool)\n            this._tool.keydown(e,\n                               this.worldToScreen.bind(this),\n                               this.screenToWorld.bind(this));\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./node_modules/ArgoDG/src/dg/view.js?");

/***/ }),

/***/ "./src/gui.js":
/*!********************!*\
  !*** ./src/gui.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"animate\": () => (/* binding */ animate),\n/* harmony export */   \"setup\": () => (/* binding */ setup)\n/* harmony export */ });\n/* harmony import */ var ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ArgoDG/src/dg/dg.js */ \"./node_modules/ArgoDG/src/dg/dg.js\");\n/* harmony import */ var ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ArgoDG/src/dg/rc.js */ \"./node_modules/ArgoDG/src/dg/rc.js\");\n/* harmony import */ var ArgoDG_src_dg_construction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ArgoDG/src/dg/construction.js */ \"./node_modules/ArgoDG/src/dg/construction.js\");\n/* harmony import */ var ArgoDG_src_dg_tool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ArgoDG/src/dg/tool.js */ \"./node_modules/ArgoDG/src/dg/tool.js\");\n/* harmony import */ var ArgoDG_src_dg_animation_buttons_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ArgoDG/src/dg/animation_buttons.js */ \"./node_modules/ArgoDG/src/dg/animation_buttons.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./json.js */ \"./src/json.js\");\n/* harmony import */ var _solution_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./solution.js */ \"./src/solution.js\");\n/* harmony import */ var _hints_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hints.js */ \"./src/hints.js\");\n\n\n\n\n\n\n\n\n\n\nfunction setup(solutionJSON) {\n    ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.setup(\"mycanvas\", { width: 500, height: 500, border: \"1px solid #ccc\"}, 0, 150, 0, 150);\n    // use global view\n    const view = ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.view();\n\n    // load solution from JSON\n    const solution = new _solution_js__WEBPACK_IMPORTED_MODULE_6__.Solution(solutionJSON);\n    // show construction to the global view (but do not interact with them)\n    const construction = solution.construction();\n    construction.addView(view);\n\n    // objects that user has constructed and enable interaction with it\n    const userConstruction = new ArgoDG_src_dg_construction_js__WEBPACK_IMPORTED_MODULE_2__.Construction();    \n    userConstruction.addView(view);\n    \n    // initialize by initially given objects in the solution\n    const givenObjects = solution.givenObjects().map(name => solution.object(name));\n\n    givenObjects.forEach(obj => {\n        userConstruction.addObject(obj);\n    });\n\n    // make tools that user can use to create his construction\n    view.setTool(new ArgoDG_src_dg_tool_js__WEBPACK_IMPORTED_MODULE_3__.ToolDragFree(view, userConstruction));\n    \n    const toolbar = new ArgoDG_src_dg_tool_js__WEBPACK_IMPORTED_MODULE_3__.ConstructionToolbar(userConstruction, ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.view(),\n                                            ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.container(),\n                                            constructionCallback);\n    // all three triangle vertices\n    const allVertices = solution.allVertices().sort().map(name => solution.object(name));\n    \n    // construct all triangle elements\n    const allTriangleElements = ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_1__.triangle(...allVertices);\n\n    // hide all constructed elements (show only elements that are initially given)\n    solution.hideConstructed();\n    \n    function constructionCallback(obj) {\n        userConstruction.addObject(obj);\n        \n        function check(knownObject) {\n            if (obj.eq(knownObject)) {\n                const name = knownObject.label();\n                obj.label(name);\n                obj.color(knownObject.color() ? knownObject.color() : \"green\");\n                hints.remove(name);\n            }\n        }\n\n        solution.forEach(check);\n        allTriangleElements.forEach(check);\n    }\n    \n    // Hints\n    const hints = new _hints_js__WEBPACK_IMPORTED_MODULE_7__.Hints(solution, userConstruction, view, document.getElementById(\"hints\"));\n    hints.show();\n}\n\nfunction animate(solutionJSON) {\n    ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.setup(\"mycanvas\", { width: 500, height: 500, border: \"1px solid #ccc\"}, 0, 150, 0, 150);\n\n    // load solution from JSON\n    const solution = new _solution_js__WEBPACK_IMPORTED_MODULE_6__.Solution(solutionJSON);\n\n    const construction = solution.construction();\n    \n    // attach construction to the global view\n    ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.setConstruction(construction);\n    \n    var animButtons = new ArgoDG_src_dg_animation_buttons_js__WEBPACK_IMPORTED_MODULE_4__.AnimationButtons(construction, ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_0__.container());\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./src/gui.js?");

/***/ }),

/***/ "./src/hints.js":
/*!**********************!*\
  !*** ./src/hints.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Hints\": () => (/* binding */ Hints)\n/* harmony export */ });\n/* harmony import */ var ArgoDG_src_dg_latex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ArgoDG/src/dg/latex.js */ \"./node_modules/ArgoDG/src/dg/latex.js\");\n/* harmony import */ var ArgoDG_src_dg_construction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ArgoDG/src/dg/construction.js */ \"./node_modules/ArgoDG/src/dg/construction.js\");\n\n\n\nclass Hints {\n    constructor(solution, userConstruction, view, element) {\n        this._solution = solution;\n        this._user_construction = userConstruction;\n        this._given = this._solution.constructedVertices().map(name => { return {name: name, describe: false}; });\n        this._objects = new ArgoDG_src_dg_construction_js__WEBPACK_IMPORTED_MODULE_1__.Construction();\n        this._objects.setView(view);\n        this._element = element;\n    }\n\n    getHints(name) {\n        let hints;\n        if (this._solution.step(name).construction == \"W05\")\n            hints = this._solution.step(name).params.slice(0, 2);\n        else\n            hints = this._solution.step(name).params.filter(p => typeof p == 'string');\n\n        return [...new Set(hints)];\n    }\n\n    show() {\n        this.showObjects();\n        this.showButtons();\n    }\n\n    showObjects() {\n        this._given.forEach(hint => {\n            if (!this._objects.includes(hint.name)) {\n                const o = this._solution.object(hint.name).clone();\n                o.color(\"red\").opacity(\"0.3\").dashed().show();\n                this._objects.addObject(o);\n            }\n        });\n    }\n\n    describeHints(name) {\n        function capitalize(str) {\n            return str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        let desc = \"\";\n        desc += capitalize(this._solution.describeStep(name)) + \".<br>\";\n\n        const notConstructed = this.getHints(name).filter(name => !this._user_construction.includes(name));\n        if (notConstructed.length > 0)\n            desc += \"Try to construct \" +\n                    notConstructed.map(name => this._solution.describeObject(name)).join(\" and \") + \".\";\n        else\n            desc += \"All needed objects are already constructed.\";\n        return desc;\n    }\n\n    showButtons() {\n        this._element.innerHTML = \"\";\n\n        const h3 = document.createElement(\"h3\");\n        h3.innerHTML = \"Hints\";\n        this._element.append(h3);\n        const p = document.createElement(\"p\");\n        const cv = this._solution.constructedVertices().filter(name => !this._user_construction.includes(name)).map(name => (0,ArgoDG_src_dg_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(name));\n        if (cv.length > 0)\n            p.innerHTML = \"All triangle vertices need to be constructed. You must construct \" + cv.join(\" and \") + \".\";\n        else {\n            p.innerHTML = \"Well done! All triangle vertices are constructed\";\n            this._solution.showTriangle();\n        }\n\n        const self = this;\n\n        this._element.append(p);\n\n        this._given.forEach((hint, i) => {\n            if (!this._user_construction.includes(hint.name)) {\n                const p = document.createElement(\"p\");\n                this._element.append(p);\n\n                const btn = document.createElement(\"button\");\n                btn.innerHTML = (0,ArgoDG_src_dg_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(hint.name);\n                p.append(btn);\n\n                if (hint.analogous) {\n                    const p_desc = document.createElement(\"p\");\n                    p_desc.innerHTML = \"This construction is completely analogous to the construction of \" + (0,ArgoDG_src_dg_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(hint.analogous) + \". \";;\n                    p.append(p_desc);\n                    return;\n                }\n\n                if (hint.describe) {\n                    const p_desc = document.createElement(\"p\");\n                    p_desc.innerHTML = this.describeHints(hint.name);\n                    p.append(p_desc);\n                }\n\n                btn.addEventListener(\"click\", function() {\n                    self._given[i].describe = true;\n\n                    const analogous = self._solution.analogous(self._given[i].name);\n                    if (analogous && self._given.some(hint => hint.name == analogous && hint.describe == true && !hint.analogous)) {\n                        self._given[i].analogous = analogous;\n                    } else {\n                        const hints = self.getHints(hint.name);\n                        hints.forEach(name => {\n                            if (!self._given.map(hint => hint.name).includes(name) && !self._user_construction.includes(name))\n                                self._given.push({name:name, describe: false});\n                        });\n                    }\n                    self.show();\n                });\n            }\n        });\n    }\n\n    removeDeprecated() {\n        // perform a DFS of the construction tree to determine hints that are still relevant\n\n        const relevantHints = new Set();\n        // start from the vertices that need to be constructed\n        const cv = this._solution.constructedVertices()\n        cv.forEach(name => relevantHints.add(name));\n        const stack = [...cv];\n        while (stack.length > 0) {\n            const name = stack.pop();\n            const hints = this.getHints(name);\n            hints.forEach(name => {\n                if (this._given.map(hint => hint.name).includes(name) && !relevantHints.has(name)) {\n                    stack.push(name);\n                    relevantHints.add(name);\n                }\n            });\n        }\n        this._given = this._given.filter(hint => relevantHints.has(hint.name));\n    }\n\n    remove(name) {\n        this._given = this._given.filter(hint => hint.name != name);\n        this.removeDeprecated();\n        this._objects.removeObject(this._objects.find(name));\n        this.show();\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./src/hints.js?");

/***/ }),

/***/ "./src/json.js":
/*!*********************!*\
  !*** ./src/json.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchJSON\": () => (/* binding */ fetchJSON)\n/* harmony export */ });\nfunction fetchJSON(file, callback) {\n    const xhttp = new XMLHttpRequest();\n    xhttp.overrideMimeType(\"application/json\");\n    xhttp.responseType = 'json';\n    xhttp.open(\"GET\", file, true);\n    xhttp.onreadystatechange = function() {\n        if (xhttp.readyState === 4 && xhttp.status == \"200\") {\n            callback(xhttp.response);\n        }\n    }\n    xhttp.send(null);\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./src/json.js?");

/***/ }),

/***/ "./src/solution.js":
/*!*************************!*\
  !*** ./src/solution.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Solution\": () => (/* binding */ Solution)\n/* harmony export */ });\n/* harmony import */ var ArgoDG_src_dg_latex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ArgoDG/src/dg/latex.js */ \"./node_modules/ArgoDG/src/dg/latex.js\");\n/* harmony import */ var ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ArgoDG/src/dg/dg.js */ \"./node_modules/ArgoDG/src/dg/dg.js\");\n/* harmony import */ var ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ArgoDG/src/dg/rc.js */ \"./node_modules/ArgoDG/src/dg/rc.js\");\n/* harmony import */ var ArgoDG_src_dg_objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ArgoDG/src/dg/objects.js */ \"./node_modules/ArgoDG/src/dg/objects.js\");\n/* harmony import */ var ArgoDG_src_dg_construction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ArgoDG/src/dg/construction.js */ \"./node_modules/ArgoDG/src/dg/construction.js\");\n\n\n\n\n\n\nconst W = {\n    free: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.free,\n    W01: (X, Z, W, p, q) => ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.towards(Z, W, X, q, p),\n    W02: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.line,\n    W03: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.intersectLL,\n    W04: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.intersectLC_both,\n    W05: (c, l, O, A) => ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.intersectLC_other(l, c, A),\n    W05a: (c, l, O, A) => ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.intersectLC_other(l, c, A),\n    W06: (X, Y) => ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.circle(Y, X),\n    W07: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.intersectCC_both,\n    W08: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.intersectCC_other,\n    W09: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.circle_over_segment,\n    W10: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.drop_perp,\n    W10a: (A, l) => ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.drop_perp(l, A),\n    W10b: (A, l) => ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.drop_perp(l, A),\n    W11: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.touching_circle,\n    W12: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.tangents,\n    W13: (c, A, O, t) => other_tangent(A, c, t),\n    W14: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.bisector,\n    W15: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.homothety_line,\n    W16: (A, l) => ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.parallel(l, A),\n    W17: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.angle_divide,\n    W19: ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.harmonic_conjugate\n};\n\n// Solution given by ArgoTriCS (parsed from JSON file)\nclass Solution {\n    constructor(solutionJSON) {\n        // dictionary mapping object names to construction steps and\n        // constructed objects\n        this._solution = {}\n        // ordered list of steps\n        this._steps = []\n        // ArgoDG construction - ordered list of objects \n        this._construction = new ArgoDG_src_dg_construction_js__WEBPACK_IMPORTED_MODULE_4__.Construction();\n        \n        // load solution from JSON\n        this.loadFromJSON(solutionJSON)\n        \n        // detecting analogous constructions is usefull for giving hints\n        this.detectAnalogousConstructions();\n    }\n\n    // construction step for the object with the given name\n    step(name) {\n        return this._solution[name].step;\n    }\n\n    // constructed object with the given name\n    object(name) {\n        return this._solution[name].object;\n    }\n\n    // ArgoDG construction\n    construction() {\n        return this._construction;\n    }\n\n    // call a function on each object\n    forEach(f) {\n        Object.keys(this._solution).forEach(name => { f(this.object(name)); });\n    }\n\n    // load from ArgoTriCS exported JSON\n    loadFromJSON(JSON) {\n        const origConstruction = ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_1__.construction();\n        ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_1__.setConstruction(this.construction());\n        JSON.forEach(step => {\n            const obj = W[step.construction](...step.params.map(name => name in this._solution ? this._solution[name][\"object\"] : name));\n            var self = this;\n            function addObject(obj, name, step) {\n                obj.label(name);\n                if (\"color\" in step)\n                    obj.color(step.color);\n                if (\"description\" in step)\n                    obj.description(step.description);\n                // set unique name in the step\n                let step_copy = {...step};\n                step_copy.name = name;\n                self._solution[name] = {\n                    \"object\": obj,\n                    \"step\": step_copy\n                };\n                self._steps.push(step_copy);\n            }\n\n            if (typeof step.name === \"string\")\n                addObject(obj, step.name, step);\n            else if (step.name.length == 1)\n                addObject(obj, step.name[0], step);\n            else if (step.name.length == 2) {\n                addObject(obj[0], step.name[0], step);\n                addObject(obj[1], step.name[1], step);\n            }\n        });\n        ArgoDG_src_dg_dg_js__WEBPACK_IMPORTED_MODULE_1__.setConstruction(origConstruction);\n    }\n\n    // names of objects that are free in the construction (initially\n    // given objects)\n    givenObjects() {\n        return Object.keys(this._solution).filter(name => this.step(name).construction == \"free\");\n    }\n\n    // names of all triangle vertices in the construction (given and constructed)\n    allVertices() {\n        return Object.keys(this._solution).filter(name => {\n            const step = this._solution[name].step;\n            return step.intriangle[0] == \"vertex\";\n        });\n    }\n\n    // triangle vertices that have been constructed\n    constructedVertices() {\n        return Object.keys(this._solution).filter(name => {\n            const step = this._solution[name].step;\n            return step.intriangle[0] == \"vertex\" && step.construction != \"free\";\n        });\n    }\n\n    // hide all constructed objects (show only objects that are initially given)\n    hideConstructed() {\n        this.hideAll();\n        this.givenObjects().forEach(name => this._solution[name].object.show());\n    }\n\n    // show all objects (given and constructed)\n    hideAll() {\n        this.showAll(false);\n    }\n    \n    // show all objects (given and constructed)\n    showAll(yes) {\n        this.forEach(obj => obj.show(yes));\n    }\n\n    // show the constructed triangle\n    showTriangle() {\n        const A = this.object('A');\n        const B = this.object('B');\n        const C = this.object('C');\n        ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.segment(A, B).color(\"blue\").width(2);\n        ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.segment(A, C).color(\"blue\").width(2);\n        ArgoDG_src_dg_rc_js__WEBPACK_IMPORTED_MODULE_2__.segment(B, C).color(\"blue\").width(2);\n    }\n\n    // group objects by their role in the triangle (vertices, sides, altitudes, ...)\n    groupByIntriangle() {\n        let groups = {};\n        for (name in this._solution) {\n            const step = this.step(name);\n            if (step.construction == \"free\")\n                continue;\n            if (\"intriangle\" in step) {\n                const intriangle = step.intriangle[0];\n                if (intriangle in groups)\n                    groups[intriangle].push(step);\n                else\n                    groups[intriangle] = [step];\n            }\n        }\n        return groups;\n    }\n\n    detectAnalogousConstructions() {\n        this._analogous = {};\n        const groups = this.groupByIntriangle();\n        for (let group in groups) {\n            const objects = groups[group];\n            for (let i = 1; i < objects.length; i++)\n                for (let j = 0; j < i; j++) {\n                    if (this.compareConstructions(objects[i].name, objects[j].name)) {\n                        this._analogous[objects[i].name] = objects[j].name;\n                        this._analogous[objects[j].name] = objects[i].name;\n                    }\n                }\n        }\n    }\n\n    analogous(name) {\n        return this._analogous[name];\n    }\n\n    compareConstructions(c1, c2) {\n        if (typeof c1 == \"number\" && typeof c2 == \"number\")\n            return parseFloat(c1) == parseFloat(c2);\n        if (!c1 in this._solution || !c2 in this._solution)\n            return false;\n        c1 = this.step(c1);\n        c2 = this.step(c2);\n        if (c1.construction != c2.construction)\n            return false;\n        if (c1.construction == \"free\")\n            return true;\n        for (let i = 0; i < c1.params.length; i++)\n            if (!this.compareConstructions(c1.params[i], c2.params[i]))\n                return false;\n        return true;\n    }\n    \n    describeObject(name) {\n        const step = this.step(name);\n        if (!\"intriangle\" in step)\n            return step.name;\n        if (step.intriangle[0] == \"circle_center_through\") {\n            const p = this.step(step.params[0]);\n            const C = this.step(step.params[1]);\n            if (p.intriangle[0] == \"vertex\" && C.intriangle[0] == \"midpoint\")\n                return \"circle \" + (0,ArgoDG_src_dg_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(step.name) + \" over segment \" + C.intriangle[1][0] + C.intriangle[1][1];\n        }\n        let intriangle = step.intriangle[0];\n        if (intriangle == \"side_bis\")\n            intriangle = \"side bisector\";\n        if (intriangle == \"angle_bis\")\n            intriangle = \"angle bisector\";\n        if (intriangle == \"circle_center_through\")\n            intriangle = \"circle\";\n        if (intriangle == \"angle_bis_foot\")\n            intriangle = \"foot of angle bisector\";\n        return intriangle + \" \" + (0,ArgoDG_src_dg_latex_js__WEBPACK_IMPORTED_MODULE_0__.laTeX2HTML)(step.name);\n    }\n\n    describeStep(name) {\n        const step = this.step(name);\n        if (step.construction == \"W01\") {\n            if (step.params[0] == step.params[1] && step.params[3] == 1 && step.params[4] == 2)\n                return this.describeObject(name) +\n                       \" is the midpoint of segment between \" +\n                       this.describeObject(step.params[1])  +\n                       \" and \" +\n                       this.describeObject(step.params[2]);\n            if (step.params[0] == step.params[1] && step.params[3] == 2 && step.params[4] == 1)\n                return this.describeObject(name) +\n                       \" is the reflection of \" +\n                       this.describeObject(step.params[1])  +\n                       \" around \" +\n                       this.describeObject(step.params[2]);\n            if (step.params[0] == step.params[1] && step.params[3] == -1 && step.params[4] == 1)\n                return this.describeObject(name) +\n                       \" is the reflection of \" +\n                       this.describeObject(step.params[2])  +\n                       \" around \" +\n                       this.describeObject(step.params[0]);\n        } else if (step.construction == \"W02\") {\n            return this.describeObject(name) +\n                   \" contains \" +\n                   this.describeObject(step.params[0])  +\n                   \" and \" +\n                   this.describeObject(step.params[1]);\n        } else if (step.construction == \"W03\") {\n            return this.describeObject(name) +\n                   \" is the intersection of \" +\n                   this.describeObject(step.params[0])  +\n                   \" and \" +\n                   this.describeObject(step.params[1]);\n        } else if (step.construction == \"W05\" || step.construction == \"W05a\") {\n            return this.describeObject(name) +\n                   \" is the intersection of \" +\n                   this.describeObject(step.params[0])  +\n                   \" and \" +\n                   this.describeObject(step.params[1]);\n        } else if (step.construction == \"W06\") {\n            return this.describeObject(name) +\n                   \" is the circle centered at \" +\n                   this.describeObject(step.params[1])  +\n                   \" that contains \" +\n                   this.describeObject(step.params[0]);\n        } else if (step.construction == \"W10a\") {\n            return this.describeObject(name) +\n                   \" contains \" +\n                   this.describeObject(step.params[0]) +\n                   \" and is perpendicular to \" +\n                   this.describeObject(step.params[1]);\n        } else if (step.construction == \"W11\") {\n            return this.describeObject(name) +\n                   \"is the circle centered in \" +\n                   this.describeObject(step.params[0]) +\n                   \" that touches \" +\n                   this.describeObject(step.params[1]);\n        } else if (step.construction == \"W13\") {\n            return this.describeObject(name) +\n                   \" contains \" +\n                   this.describeObject(step.params[1]) +\n                   \" and is tangent to \" +\n                   this.describeObject(step.params[0]) +\n                   \" that is different from \" +\n                   this.describeObject(step.params[3]);\n        } else if (step.construction == \"W14\") {\n            return this.describeObject(name) +\n                   \"is the bisector of segment formed by \" +\n                   this.describeObject(step.params[0]) +\n                   \" and \" +\n                   this.describeObject(step.params[1]);\n        } else if (step.construction == \"W16\") {\n            return this.describeObject(name) +\n                   \" contains \" +\n                   this.describeObject(step.params[0]) +\n                   \" and is parallel to \" +\n                   this.describeObject(step.params[1]);\n        }\n        return step.construction;\n    }\n}\n\n\n\n\n//# sourceURL=webpack://ArgoTriCSGUI/./src/solution.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/gui.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});